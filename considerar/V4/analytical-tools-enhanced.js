/* ==========================================================================\n   BIBLIAAPP PRO v3.0 - ENHANCED ANALYTICAL TOOLS MODULE\n   Advanced analytical functions with frequency analysis, correlations, and patterns\n   ========================================================================== */\n\nimport { $, $$, createElement, debounce, deepClone } from '../core/utils.js';\nimport { ANALYTICAL_TOOLS } from '../core/constants.js';\nimport stateManager, { getState, setState, subscribe } from '../core/state-manager.js';\nimport uiManager from '../core/ui-manager.js';\n\n// ==========================================\n// ENHANCED ANALYTICAL TOOLS CLASS\n// ==========================================\n\nclass AnalyticalToolsEnhanced {\n    constructor() {\n        this.config = {\n            debugMode: false,\n            precisionLevel: 2,\n            correlationThreshold: 0.7,\n            maxVisualizationElements: 100,\n            analysisCache: new Map(),\n            batchSize: 50\n        };\n        \n        this.analysisData = {\n            frequency: {},\n            correlations: {},\n            patterns: [],\n            themes: {},\n            statistics: {\n                global: {},\n                byBook: {},\n                byCategory: {},\n                temporal: {}\n            }\n        };\n        \n        this.activeAnalyses = new Set();\n        this.analysisHistory = [];\n        this.customFilters = [];\n        \n        this.isInitialized = false;\n        this.initializeSystem();\n    }\n    \n    /**\n     * Initialize Analytical Tools System\n     */\n    async initializeSystem() {\n        try {\n            // Load analytical configurations\n            await this.loadAnalyticalConfigs();\n            \n            // Setup analysis categories\n            this.setupAnalysisCategories();\n            \n            // Initialize statistical models\n            this.initializeStatisticalModels();\n            \n            // Setup state subscriptions\n            this.setupStateSubscriptions();\n            \n            this.isInitialized = true;\n            console.log('✅ Enhanced Analytical Tools system initialized');\n            \n        } catch (error) {\n            console.error('Failed to initialize Analytical Tools system:', error);\n        }\n    }\n    \n    /**\n     * Load analytical configurations\n     */\n    async loadAnalyticalConfigs() {\n        // Load saved analysis preferences\n        const savedConfig = getState('analytics.config', {});\n        Object.assign(this.config, savedConfig);\n        \n        // Load custom filters\n        this.customFilters = getState('analytics.customFilters', []);\n        \n        console.log('⚙️ Analytical configurations loaded');\n    }\n    \n    /**\n     * Setup analysis categories with advanced tools\n     */\n    setupAnalysisCategories() {\n        this.analysisCategories = {\n            hermeneutics: {\n                name: 'Hermenéutica',\n                color: '#4CAF50',\n                tools: [\n                    {\n                        id: 'contextual_analysis',\n                        name: 'Análisis Contextual',\n                        description: 'Examina el contexto histórico, cultural y literario',\n                        difficulty: 'intermediate',\n                        method: 'contextual'\n                    },\n                    {\n                        id: 'grammatical_analysis',\n                        name: 'Análisis Gramatical',\n                        description: 'Estudia la estructura gramatical y sintáctica del texto',\n                        difficulty: 'advanced',\n                        method: 'grammatical'\n                    },\n                    {\n                        id: 'literary_structure',\n                        name: 'Estructura Literaria',\n                        description: 'Identifica patrones y estructuras literarias',\n                        difficulty: 'intermediate',\n                        method: 'literary'\n                    },\n                    {\n                        id: 'semantic_analysis',\n                        name: 'Análisis Semántico',\n                        description: 'Estudia el significado de palabras y conceptos',\n                        difficulty: 'advanced',\n                        method: 'semantic'\n                    },\n                    {\n                        id: 'rhetorical_analysis',\n                        name: 'Análisis Retórico',\n                        description: 'Examina técnicas retóricas y persuasivas',\n                        difficulty: 'expert',\n                        method: 'rhetorical'\n                    }\n                ]\n            },\n            textualCriticism: {\n                name: 'Crítica Textual',\n                color: '#2196F3',\n                tools: [\n                    {\n                        id: 'manuscript_comparison',\n                        name: 'Comparación de Manuscritos',\n                        description: 'Compara variantes textuales entre manuscritos',\n                        difficulty: 'expert',\n                        method: 'manuscript'\n                    },\n                    {\n                        id: 'textual_variants',\n                        name: 'Análisis de Variantes',\n                        description: 'Identifica y evalúa variantes textuales',\n                        difficulty: 'advanced',\n                        method: 'variants'\n                    },\n                    {\n                        id: 'translation_comparison',\n                        name: 'Comparación de Traducciones',\n                        description: 'Compara diferentes traducciones bíblicas',\n                        difficulty: 'intermediate',\n                        method: 'translation'\n                    },\n                    {\n                        id: 'original_language',\n                        name: 'Análisis de Idioma Original',\n                        description: 'Estudia el texto en hebreo/griego original',\n                        difficulty: 'expert',\n                        method: 'original'\n                    }\n                ]\n            },\n            linguistics: {\n                name: 'Lingüística',\n                color: '#FF9800',\n                tools: [\n                    {\n                        id: 'word_frequency',\n                        name: 'Frecuencia de Palabras',\n                        description: 'Analiza la frecuencia y distribución de palabras',\n                        difficulty: 'beginner',\n                        method: 'frequency'\n                    },\n                    {\n                        id: 'concordance_analysis',\n                        name: 'Análisis de Concordancia',\n                        description: 'Encuentra todas las ocurrencias de palabras clave',\n                        difficulty: 'beginner',\n                        method: 'concordance'\n                    },\n                    {\n                        id: 'semantic_field',\n                        name: 'Campo Semántico',\n                        description: 'Estudia grupos de palabras relacionadas semánticamente',\n                        difficulty: 'intermediate',\n                        method: 'semantic_field'\n                    },\n                    {\n                        id: 'syntax_patterns',\n                        name: 'Patrones Sintácticos',\n                        description: 'Identifica estructuras sintácticas recurrentes',\n                        difficulty: 'advanced',\n                        method: 'syntax'\n                    },\n                    {\n                        id: 'discourse_analysis',\n                        name: 'Análisis del Discurso',\n                        description: 'Examina la estructura y flujo del discurso',\n                        difficulty: 'advanced',\n                        method: 'discourse'\n                    }\n                ]\n            },\n            archaeology: {\n                name: 'Arqueología',\n                color: '#795548',\n                tools: [\n                    {\n                        id: 'historical_context',\n                        name: 'Contexto Histórico',\n                        description: 'Relaciona el texto con hallazgos arqueológicos',\n                        difficulty: 'intermediate',\n                        method: 'historical'\n                    },\n                    {\n                        id: 'cultural_background',\n                        name: 'Trasfondo Cultural',\n                        description: 'Examina prácticas culturales de la época',\n                        difficulty: 'intermediate',\n                        method: 'cultural'\n                    },\n                    {\n                        id: 'geographical_analysis',\n                        name: 'Análisis Geográfico',\n                        description: 'Estudia la geografía y topografía bíblica',\n                        difficulty: 'beginner',\n                        method: 'geographical'\n                    },\n                    {\n                        id: 'chronological_study',\n                        name: 'Estudio Cronológico',\n                        description: 'Establece secuencias temporales de eventos',\n                        difficulty: 'intermediate',\n                        method: 'chronological'\n                    }\n                ]\n            },\n            theology: {\n                name: 'Teología',\n                color: '#9C27B0',\n                tools: [\n                    {\n                        id: 'doctrinal_analysis',\n                        name: 'Análisis Doctrinal',\n                        description: 'Examina enseñanzas doctrinales en el texto',\n                        difficulty: 'advanced',\n                        method: 'doctrinal'\n                    },\n                    {\n                        id: 'theological_themes',\n                        name: 'Temas Teológicos',\n                        description: 'Identifica y analiza temas teológicos principales',\n                        difficulty: 'intermediate',\n                        method: 'theological'\n                    },\n                    {\n                        id: 'covenant_analysis',\n                        name: 'Análisis de Pactos',\n                        description: 'Estudia los pactos bíblicos y su desarrollo',\n                        difficulty: 'advanced',\n                        method: 'covenant'\n                    },\n                    {\n                        id: 'eschatological_study',\n                        name: 'Estudio Escatológico',\n                        description: 'Examina temas relacionados con los últimos tiempos',\n                        difficulty: 'advanced',\n                        method: 'eschatological'\n                    },\n                    {\n                        id: 'christological_analysis',\n                        name: 'Análisis Cristológico',\n                        description: 'Estudia referencias y tipologías de Cristo',\n                        difficulty: 'intermediate',\n                        method: 'christological'\n                    }\n                ]\n            },\n            statistical: {\n                name: 'Análisis Estadístico',\n                color: '#607D8B',\n                tools: [\n                    {\n                        id: 'correlation_matrix',\n                        name: 'Matriz de Correlación',\n                        description: 'Calcula correlaciones entre términos y conceptos',\n                        difficulty: 'advanced',\n                        method: 'correlation'\n                    },\n                    {\n                        id: 'cluster_analysis',\n                        name: 'Análisis de Clusters',\n                        description: 'Agrupa textos por similitud temática',\n                        difficulty: 'expert',\n                        method: 'clustering'\n                    },\n                    {\n                        id: 'trend_analysis',\n                        name: 'Análisis de Tendencias',\n                        description: 'Identifica tendencias temporales en el corpus',\n                        difficulty: 'advanced',\n                        method: 'trends'\n                    },\n                    {\n                        id: 'network_analysis',\n                        name: 'Análisis de Redes',\n                        description: 'Modela relaciones entre conceptos como red',\n                        difficulty: 'expert',\n                        method: 'network'\n                    },\n                    {\n                        id: 'sentiment_analysis',\n                        name: 'Análisis de Sentimiento',\n                        description: 'Evalúa el tono emocional del texto',\n                        difficulty: 'intermediate',\n                        method: 'sentiment'\n                    }\n                ]\n            },\n            advanced: {\n                name: 'Herramientas Avanzadas',\n                color: '#E91E63',\n                tools: [\n                    {\n                        id: 'intertextuality',\n                        name: 'Análisis Intertextual',\n                        description: 'Identifica conexiones entre diferentes textos',\n                        difficulty: 'expert',\n                        method: 'intertextual'\n                    },\n                    {\n                        id: 'typological_study',\n                        name: 'Estudio Tipológico',\n                        description: 'Identifica tipos y antitipos bíblicos',\n                        difficulty: 'advanced',\n                        method: 'typological'\n                    },\n                    {\n                        id: 'narrative_analysis',\n                        name: 'Análisis Narrativo',\n                        description: 'Examina estructura y elementos narrativos',\n                        difficulty: 'intermediate',\n                        method: 'narrative'\n                    },\n                    {\n                        id: 'metaphor_analysis',\n                        name: 'Análisis de Metáforas',\n                        description: 'Identifica y analiza uso de metáforas',\n                        difficulty: 'intermediate',\n                        method: 'metaphor'\n                    },\n                    {\n                        id: 'genre_analysis',\n                        name: 'Análisis de Género Literario',\n                        description: 'Clasifica y analiza géneros literarios',\n                        difficulty: 'intermediate',\n                        method: 'genre'\n                    }\n                ]\n            }\n        };\n        \n        console.log('📊 Analysis categories configured with', this.getTotalToolsCount(), 'tools');\n    }\n    \n    /**\n     * Initialize statistical models\n     */\n    initializeStatisticalModels() {\n        this.statisticalModels = {\n            frequencyModel: new FrequencyAnalysisModel(),\n            correlationModel: new CorrelationAnalysisModel(),\n            clusteringModel: new ClusteringModel(),\n            sentimentModel: new SentimentAnalysisModel(),\n            networkModel: new NetworkAnalysisModel()\n        };\n        \n        console.log('🔢 Statistical models initialized');\n    }\n    \n    // ==========================================\n    // ANALYSIS EXECUTION\n    // ==========================================\n    \n    /**\n     * Execute analytical tool\n     * @param {string} toolId - Tool identifier\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Analysis results\n     */\n    async executeAnalysis(toolId, text, options = {}) {\n        const tool = this.findToolById(toolId);\n        if (!tool) {\n            throw new Error(`Tool not found: ${toolId}`);\n        }\n        \n        // Check cache first\n        const cacheKey = this.generateCacheKey(toolId, text, options);\n        if (this.config.analysisCache.has(cacheKey)) {\n            console.log(`📋 Using cached analysis for ${toolId}`);\n            return this.config.analysisCache.get(cacheKey);\n        }\n        \n        const startTime = performance.now();\n        this.activeAnalyses.add(toolId);\n        \n        try {\n            let results;\n            \n            switch (tool.method) {\n                case 'frequency':\n                    results = await this.executeFrequencyAnalysis(text, options);\n                    break;\n                case 'concordance':\n                    results = await this.executeConcordanceAnalysis(text, options);\n                    break;\n                case 'correlation':\n                    results = await this.executeCorrelationAnalysis(text, options);\n                    break;\n                case 'semantic':\n                    results = await this.executeSemanticAnalysis(text, options);\n                    break;\n                case 'contextual':\n                    results = await this.executeContextualAnalysis(text, options);\n                    break;\n                case 'grammatical':\n                    results = await this.executeGrammaticalAnalysis(text, options);\n                    break;\n                case 'sentiment':\n                    results = await this.executeSentimentAnalysis(text, options);\n                    break;\n                case 'clustering':\n                    results = await this.executeClusteringAnalysis(text, options);\n                    break;\n                case 'network':\n                    results = await this.executeNetworkAnalysis(text, options);\n                    break;\n                default:\n                    results = await this.executeGenericAnalysis(tool, text, options);\n            }\n            \n            const endTime = performance.now();\n            const executionTime = endTime - startTime;\n            \n            // Enhance results with metadata\n            const enhancedResults = {\n                ...results,\n                metadata: {\n                    toolId,\n                    toolName: tool.name,\n                    executionTime,\n                    textLength: text.length,\n                    timestamp: Date.now(),\n                    options\n                }\n            };\n            \n            // Cache results\n            this.config.analysisCache.set(cacheKey, enhancedResults);\n            \n            // Add to history\n            this.analysisHistory.push({\n                toolId,\n                timestamp: Date.now(),\n                executionTime,\n                resultsPreview: this.generateResultsPreview(enhancedResults)\n            });\n            \n            // Update statistics\n            this.updateAnalysisStatistics(toolId, enhancedResults);\n            \n            console.log(`✅ Analysis completed: ${tool.name} (${executionTime.toFixed(2)}ms)`);\n            \n            return enhancedResults;\n            \n        } catch (error) {\n            console.error(`❌ Analysis failed: ${tool.name}`, error);\n            throw error;\n        } finally {\n            this.activeAnalyses.delete(toolId);\n        }\n    }\n    \n    /**\n     * Execute frequency analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Frequency analysis results\n     */\n    async executeFrequencyAnalysis(text, options = {}) {\n        const {\n            minWordLength = 3,\n            excludeStopWords = true,\n            caseSensitive = false,\n            includeNumbers = false\n        } = options;\n        \n        const processedText = caseSensitive ? text : text.toLowerCase();\n        const words = processedText.match(/\\b\\w+\\b/g) || [];\n        \n        // Filter words\n        const filteredWords = words.filter(word => {\n            if (word.length < minWordLength) return false;\n            if (!includeNumbers && /\\d/.test(word)) return false;\n            if (excludeStopWords && this.isStopWord(word)) return false;\n            return true;\n        });\n        \n        // Calculate frequencies\n        const wordFreq = {};\n        const totalWords = filteredWords.length;\n        \n        filteredWords.forEach(word => {\n            wordFreq[word] = (wordFreq[word] || 0) + 1;\n        });\n        \n        // Sort by frequency\n        const sortedWords = Object.entries(wordFreq)\n            .sort(([,a], [,b]) => b - a)\n            .map(([word, count]) => ({\n                word,\n                count,\n                frequency: (count / totalWords * 100).toFixed(this.config.precisionLevel),\n                relativeFrequency: count / Math.max(...Object.values(wordFreq))\n            }));\n        \n        // Calculate statistics\n        const statistics = {\n            totalWords,\n            uniqueWords: Object.keys(wordFreq).length,\n            averageWordLength: filteredWords.reduce((sum, word) => sum + word.length, 0) / totalWords,\n            lexicalDiversity: Object.keys(wordFreq).length / totalWords,\n            mostFrequentWord: sortedWords[0],\n            hapaxLegomena: sortedWords.filter(item => item.count === 1).length\n        };\n        \n        return {\n            type: 'frequency_analysis',\n            words: sortedWords.slice(0, 100), // Top 100\n            statistics,\n            wordcloud: this.generateWordCloudData(sortedWords.slice(0, 50)),\n            distribution: this.calculateFrequencyDistribution(sortedWords)\n        };\n    }\n    \n    /**\n     * Execute concordance analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Concordance analysis results\n     */\n    async executeConcordanceAnalysis(text, options = {}) {\n        const {\n            searchTerm,\n            contextWindow = 50,\n            caseSensitive = false\n        } = options;\n        \n        if (!searchTerm) {\n            throw new Error('Search term is required for concordance analysis');\n        }\n        \n        const processedText = caseSensitive ? text : text.toLowerCase();\n        const processedTerm = caseSensitive ? searchTerm : searchTerm.toLowerCase();\n        \n        const regex = new RegExp(`\\\\b${processedTerm}\\\\b`, 'gi');\n        const matches = [];\n        let match;\n        \n        while ((match = regex.exec(processedText)) !== null) {\n            const start = Math.max(0, match.index - contextWindow);\n            const end = Math.min(text.length, match.index + match[0].length + contextWindow);\n            \n            const context = text.substring(start, end);\n            const leftContext = text.substring(start, match.index);\n            const rightContext = text.substring(match.index + match[0].length, end);\n            \n            matches.push({\n                index: match.index,\n                term: match[0],\n                leftContext: leftContext.trim(),\n                rightContext: rightContext.trim(),\n                fullContext: context.trim(),\n                position: {\n                    line: (processedText.substring(0, match.index).match(/\\n/g) || []).length + 1,\n                    character: match.index - (processedText.lastIndexOf('\\n', match.index) + 1)\n                }\n            });\n        }\n        \n        // Calculate collocations (words that frequently appear near the search term)\n        const collocations = this.calculateCollocations(matches, 5);\n        \n        return {\n            type: 'concordance_analysis',\n            searchTerm,\n            totalOccurrences: matches.length,\n            matches: matches.slice(0, 200), // Limit to 200 matches\n            collocations,\n            statistics: {\n                averageContextLength: matches.reduce((sum, m) => sum + m.fullContext.length, 0) / matches.length,\n                distribution: this.calculateDistribution(matches, text.length)\n            }\n        };\n    }\n    \n    /**\n     * Execute correlation analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Correlation analysis results\n     */\n    async executeCorrelationAnalysis(text, options = {}) {\n        const {\n            terms = [],\n            windowSize = 100,\n            minCorrelation = 0.3\n        } = options;\n        \n        if (terms.length < 2) {\n            throw new Error('At least 2 terms are required for correlation analysis');\n        }\n        \n        // Divide text into windows\n        const windows = this.divideTextIntoWindows(text, windowSize);\n        \n        // Calculate term occurrences in each window\n        const termOccurrences = {};\n        terms.forEach(term => {\n            termOccurrences[term] = windows.map(window => \n                (window.toLowerCase().match(new RegExp(`\\\\b${term.toLowerCase()}\\\\b`, 'g')) || []).length\n            );\n        });\n        \n        // Calculate correlation matrix\n        const correlationMatrix = {};\n        \n        for (let i = 0; i < terms.length; i++) {\n            correlationMatrix[terms[i]] = {};\n            for (let j = 0; j < terms.length; j++) {\n                if (i === j) {\n                    correlationMatrix[terms[i]][terms[j]] = 1;\n                } else {\n                    const correlation = this.calculatePearsonCorrelation(\n                        termOccurrences[terms[i]],\n                        termOccurrences[terms[j]]\n                    );\n                    correlationMatrix[terms[i]][terms[j]] = correlation;\n                }\n            }\n        }\n        \n        // Find significant correlations\n        const significantCorrelations = [];\n        for (const term1 of terms) {\n            for (const term2 of terms) {\n                if (term1 !== term2) {\n                    const correlation = correlationMatrix[term1][term2];\n                    if (Math.abs(correlation) >= minCorrelation) {\n                        significantCorrelations.push({\n                            term1,\n                            term2,\n                            correlation,\n                            strength: this.getCorrelationStrength(correlation)\n                        });\n                    }\n                }\n            }\n        }\n        \n        return {\n            type: 'correlation_analysis',\n            terms,\n            correlationMatrix,\n            significantCorrelations: significantCorrelations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation)),\n            statistics: {\n                totalWindows: windows.length,\n                windowSize,\n                averageCorrelation: this.calculateAverageCorrelation(correlationMatrix),\n                strongestCorrelation: significantCorrelations[0] || null\n            },\n            visualization: this.generateCorrelationVisualization(correlationMatrix)\n        };\n    }\n    \n    /**\n     * Execute semantic analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Semantic analysis results\n     */\n    async executeSemanticAnalysis(text, options = {}) {\n        const {\n            semanticFields = [],\n            includeWordNet = false,\n            analyzeMetaphors = true\n        } = options;\n        \n        // Extract semantic concepts\n        const concepts = this.extractSemanticConcepts(text);\n        \n        // Analyze semantic fields\n        const fieldAnalysis = this.analyzeSemanticFields(text, semanticFields);\n        \n        // Detect metaphorical language\n        const metaphors = analyzeMetaphors ? this.detectMetaphors(text) : [];\n        \n        // Analyze semantic relationships\n        const relationships = this.analyzeSemanticRelationships(concepts);\n        \n        return {\n            type: 'semantic_analysis',\n            concepts,\n            semanticFields: fieldAnalysis,\n            metaphors,\n            relationships,\n            statistics: {\n                totalConcepts: concepts.length,\n                metaphorCount: metaphors.length,\n                semanticDensity: concepts.length / text.split(/\\s+/).length,\n                dominantFields: fieldAnalysis.slice(0, 5)\n            }\n        };\n    }\n    \n    /**\n     * Execute contextual analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Contextual analysis results\n     */\n    async executeContextualAnalysis(text, options = {}) {\n        const {\n            includeHistorical = true,\n            includeCultural = true,\n            includeGeographical = true,\n            referencePeriod = 'biblical'\n        } = options;\n        \n        const analysis = {\n            type: 'contextual_analysis',\n            historical: null,\n            cultural: null,\n            geographical: null,\n            literary: null\n        };\n        \n        if (includeHistorical) {\n            analysis.historical = this.analyzeHistoricalContext(text, referencePeriod);\n        }\n        \n        if (includeCultural) {\n            analysis.cultural = this.analyzeCulturalContext(text);\n        }\n        \n        if (includeGeographical) {\n            analysis.geographical = this.analyzeGeographicalContext(text);\n        }\n        \n        // Always include literary context\n        analysis.literary = this.analyzeLiteraryContext(text);\n        \n        return analysis;\n    }\n    \n    /**\n     * Execute sentiment analysis\n     * @param {string} text - Text to analyze\n     * @param {Object} options - Analysis options\n     * @returns {Object} Sentiment analysis results\n     */\n    async executeSentimentAnalysis(text, options = {}) {\n        const {\n            granularity = 'verse', // 'word', 'sentence', 'verse', 'chapter'\n            includeEmotions = true,\n            biblicalContext = true\n        } = options;\n        \n        // Use biblical-specific sentiment lexicon\n        const sentimentLexicon = this.getBiblicalSentimentLexicon();\n        \n        // Analyze by specified granularity\n        const segments = this.segmentText(text, granularity);\n        const segmentAnalysis = segments.map(segment => {\n            const sentiment = this.analyzeSentimentForSegment(segment, sentimentLexicon);\n            return {\n                text: segment,\n                sentiment,\n                emotions: includeEmotions ? this.analyzeEmotions(segment) : null\n            };\n        });\n        \n        // Calculate overall sentiment\n        const overallSentiment = this.calculateOverallSentiment(segmentAnalysis);\n        \n        return {\n            type: 'sentiment_analysis',\n            overallSentiment,\n            segmentAnalysis,\n            distribution: this.calculateSentimentDistribution(segmentAnalysis),\n            trends: this.calculateSentimentTrends(segmentAnalysis),\n            statistics: {\n                totalSegments: segments.length,\n                positiveSegments: segmentAnalysis.filter(s => s.sentiment.polarity > 0).length,\n                negativeSegments: segmentAnalysis.filter(s => s.sentiment.polarity < 0).length,\n                neutralSegments: segmentAnalysis.filter(s => s.sentiment.polarity === 0).length\n            }\n        };\n    }\n    \n    // ==========================================\n    // UTILITY METHODS\n    // ==========================================\n    \n    /**\n     * Find tool by ID\n     * @param {string} toolId - Tool ID\n     * @returns {Object|null} Tool object\n     */\n    findToolById(toolId) {\n        for (const category of Object.values(this.analysisCategories)) {\n            const tool = category.tools.find(t => t.id === toolId);\n            if (tool) return tool;\n        }\n        return null;\n    }\n    \n    /**\n     * Get total tools count\n     * @returns {number} Total number of tools\n     */\n    getTotalToolsCount() {\n        return Object.values(this.analysisCategories)\n            .reduce((total, category) => total + category.tools.length, 0);\n    }\n    \n    /**\n     * Generate cache key\n     * @param {string} toolId - Tool ID\n     * @param {string} text - Text\n     * @param {Object} options - Options\n     * @returns {string} Cache key\n     */\n    generateCacheKey(toolId, text, options) {\n        const textHash = this.simpleHash(text);\n        const optionsHash = this.simpleHash(JSON.stringify(options));\n        return `${toolId}_${textHash}_${optionsHash}`;\n    }\n    \n    /**\n     * Simple hash function\n     * @param {string} str - String to hash\n     * @returns {string} Hash\n     */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        return Math.abs(hash).toString(36);\n    }\n    \n    /**\n     * Check if word is a stop word\n     * @param {string} word - Word to check\n     * @returns {boolean} True if stop word\n     */\n    isStopWord(word) {\n        const stopWords = new Set([\n            'el', 'la', 'de', 'que', 'y', 'a', 'en', 'un', 'es', 'se', 'no', 'te', 'lo', 'le',\n            'da', 'su', 'por', 'son', 'con', 'para', 'al', 'del', 'los', 'las', 'una', 'como',\n            'pero', 'sus', 'muy', 'sin', 'hasta', 'desde', 'sobre', 'este', 'esta', 'todo',\n            'todos', 'más', 'si', 'ya', 'vez', 'ser', 'han', 'fue', 'o', 'ni', 'me', 'mi'\n        ]);\n        return stopWords.has(word.toLowerCase());\n    }\n    \n    /**\n     * Calculate Pearson correlation coefficient\n     * @param {Array} x - First array\n     * @param {Array} y - Second array\n     * @returns {number} Correlation coefficient\n     */\n    calculatePearsonCorrelation(x, y) {\n        if (x.length !== y.length || x.length === 0) return 0;\n        \n        const n = x.length;\n        const sumX = x.reduce((a, b) => a + b, 0);\n        const sumY = y.reduce((a, b) => a + b, 0);\n        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n        const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n        const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);\n        \n        const numerator = n * sumXY - sumX * sumY;\n        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n        \n        return denominator === 0 ? 0 : numerator / denominator;\n    }\n    \n    /**\n     * Get correlation strength description\n     * @param {number} correlation - Correlation value\n     * @returns {string} Strength description\n     */\n    getCorrelationStrength(correlation) {\n        const abs = Math.abs(correlation);\n        if (abs >= 0.8) return 'muy fuerte';\n        if (abs >= 0.6) return 'fuerte';\n        if (abs >= 0.4) return 'moderada';\n        if (abs >= 0.2) return 'débil';\n        return 'muy débil';\n    }\n    \n    /**\n     * Divide text into windows\n     * @param {string} text - Text to divide\n     * @param {number} windowSize - Size of each window\n     * @returns {Array} Array of text windows\n     */\n    divideTextIntoWindows(text, windowSize) {\n        const words = text.split(/\\s+/);\n        const windows = [];\n        \n        for (let i = 0; i < words.length; i += windowSize) {\n            windows.push(words.slice(i, i + windowSize).join(' '));\n        }\n        \n        return windows;\n    }\n    \n    /**\n     * Generate results preview\n     * @param {Object} results - Analysis results\n     * @returns {string} Preview text\n     */\n    generateResultsPreview(results) {\n        switch (results.type) {\n            case 'frequency_analysis':\n                return `${results.statistics.uniqueWords} palabras únicas, más frecuente: \"${results.statistics.mostFrequentWord?.word}\"`;\n            case 'concordance_analysis':\n                return `${results.totalOccurrences} ocurrencias de \"${results.searchTerm}\"`;\n            case 'correlation_analysis':\n                return `${results.significantCorrelations.length} correlaciones significativas`;\n            case 'sentiment_analysis':\n                return `Sentimiento: ${results.overallSentiment.label} (${results.overallSentiment.score.toFixed(2)})`;\n            default:\n                return 'Análisis completado';\n        }\n    }\n    \n    /**\n     * Update analysis statistics\n     * @param {string} toolId - Tool ID\n     * @param {Object} results - Analysis results\n     */\n    updateAnalysisStatistics(toolId, results) {\n        if (!this.analysisData.statistics.global[toolId]) {\n            this.analysisData.statistics.global[toolId] = {\n                usageCount: 0,\n                totalExecutionTime: 0,\n                averageExecutionTime: 0\n            };\n        }\n        \n        const stats = this.analysisData.statistics.global[toolId];\n        stats.usageCount++;\n        stats.totalExecutionTime += results.metadata.executionTime;\n        stats.averageExecutionTime = stats.totalExecutionTime / stats.usageCount;\n    }\n    \n    /**\n     * Setup state subscriptions\n     */\n    setupStateSubscriptions() {\n        // Subscribe to analysis configuration changes\n        subscribe('analytics.config', (config) => {\n            Object.assign(this.config, config);\n        });\n        \n        // Subscribe to filter changes for integration\n        subscribe('ui.filters', (filters) => {\n            // Integration with filter system\n            console.log('📊 Integrating with filters:', filters);\n        });\n    }\n    \n    // ==========================================\n    // PUBLIC API METHODS\n    // ==========================================\n    \n    /**\n     * Get available tools by category\n     * @param {string} categoryId - Category ID\n     * @returns {Array} Tools array\n     */\n    getToolsByCategory(categoryId) {\n        return this.analysisCategories[categoryId]?.tools || [];\n    }\n    \n    /**\n     * Get all analysis categories\n     * @returns {Object} Categories object\n     */\n    getAllCategories() {\n        return this.analysisCategories;\n    }\n    \n    /**\n     * Get analysis history\n     * @param {number} limit - Maximum entries to return\n     * @returns {Array} History entries\n     */\n    getAnalysisHistory(limit = 10) {\n        return this.analysisHistory.slice(-limit).reverse();\n    }\n    \n    /**\n     * Clear analysis cache\n     */\n    clearCache() {\n        this.config.analysisCache.clear();\n        uiManager.showNotification(\n            'Caché de análisis limpiado',\n            'info',\n            { duration: 2000 }\n        );\n    }\n    \n    /**\n     * Export analysis data\n     * @returns {Object} Export data\n     */\n    exportData() {\n        return {\n            analysisData: this.analysisData,\n            analysisHistory: this.analysisHistory,\n            customFilters: this.customFilters,\n            config: { ...this.config, analysisCache: null }, // Exclude cache\n            exported: Date.now()\n        };\n    }\n    \n    /**\n     * Get system statistics\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return {\n            totalTools: this.getTotalToolsCount(),\n            categoriesCount: Object.keys(this.analysisCategories).length,\n            activeAnalyses: this.activeAnalyses.size,\n            historyLength: this.analysisHistory.length,\n            cacheSize: this.config.analysisCache.size,\n            customFilters: this.customFilters.length,\n            globalStats: this.analysisData.statistics.global,\n            isInitialized: this.isInitialized\n        };\n    }\n    \n    /**\n     * Debug method\n     */\n    debug() {\n        console.group('🔬 Enhanced Analytical Tools Debug');\n        console.log('Statistics:', this.getStats());\n        console.log('Analysis categories:', Object.keys(this.analysisCategories));\n        console.log('Active analyses:', Array.from(this.activeAnalyses));\n        console.log('Recent history:', this.getAnalysisHistory(5));\n        console.groupEnd();\n    }\n}\n\n// ==========================================\n// STATISTICAL MODELS (Placeholder Classes)\n// ==========================================\n\nclass FrequencyAnalysisModel {\n    constructor() {\n        this.initialized = true;\n    }\n}\n\nclass CorrelationAnalysisModel {\n    constructor() {\n        this.initialized = true;\n    }\n}\n\nclass ClusteringModel {\n    constructor() {\n        this.initialized = true;\n    }\n}\n\nclass SentimentAnalysisModel {\n    constructor() {\n        this.initialized = true;\n    }\n}\n\nclass NetworkAnalysisModel {\n    constructor() {\n        this.initialized = true;\n    }\n}\n\n// ==========================================\n// CREATE AND EXPORT ANALYTICAL TOOLS INSTANCE\n// ==========================================\n\nconst analyticalToolsEnhanced = new AnalyticalToolsEnhanced();\n\nexport default analyticalToolsEnhanced;\nexport { AnalyticalToolsEnhanced };"
