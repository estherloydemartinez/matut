/**
 * BibliaApp Pro - Router
 * Sistema de NavegaciÃ³n Avanzado
 */

class AppRouter {
    constructor() {
        this.routes = new Map();
        this.currentRoute = null;
        this.history = [];
        this.listeners = [];
        
        // ConfiguraciÃ³n
        this.config = {
            baseUrl: window.location.origin,
            useHash: true, // Para compatibilidad con archivo local
            defaultRoute: 'inicio',
            maxHistorySize: 50
        };
        
        // Estado
        this.initialized = false;
        this.navigating = false;
        
        // Bind methods
        this.init = this.init.bind(this);
        this.handlePopState = this.handlePopState.bind(this);
        this.handleHashChange = this.handleHashChange.bind(this);
    }
    
    /**
     * Inicializar router
     */
    init() {\n        console.log('ðŸš¦ Inicializando Router...');\n        \n        // Definir rutas\n        this.defineRoutes();\n        \n        // Configurar event listeners\n        this.setupEventListeners();\n        \n        // Navegar a ruta inicial\n        this.navigateToInitialRoute();\n        \n        this.initialized = true;\n        console.log('âœ… Router inicializado');\n    }\n    \n    /**\n     * Definir rutas de la aplicaciÃ³n\n     */\n    defineRoutes() {\n        // Ruta de inicio\n        this.addRoute('inicio', {\n            path: '/inicio',\n            component: 'InicioSection',\n            title: 'Inicio - BibliaApp Pro',\n            requiresAuth: false,\n            preload: true\n        });\n        \n        // Rutas de teorÃ­a\n        this.addRoute('teoria', {\n            path: '/teoria',\n            component: 'TeoriaSection',\n            title: 'TeorÃ­a BÃ­blica - BibliaApp Pro',\n            requiresAuth: false,\n            children: {\n                'lectura': {\n                    path: '/teoria/lectura',\n                    component: 'LecturaModule',\n                    title: 'Lectura BÃ­blica'\n                },\n                'lectura/simple': {\n                    path: '/teoria/lectura/simple',\n                    component: 'LecturaSimple',\n                    title: 'Modo Simple'\n                },\n                'lectura/profundo': {\n                    path: '/teoria/lectura/profundo',\n                    component: 'LecturaProfunda',\n                    title: 'Modo Profundo'\n                },\n                'memoria': {\n                    path: '/teoria/memoria',\n                    component: 'MemoriaModule',\n                    title: 'MemorizaciÃ³n'\n                }\n            }\n        });\n        \n        // Rutas de prÃ¡ctica\n        this.addRoute('practica', {\n            path: '/practica',\n            component: 'PracticaSection',\n            title: 'PrÃ¡ctica Cristiana - BibliaApp Pro',\n            requiresAuth: false,\n            children: {\n                'oracion': {\n                    path: '/practica/oracion',\n                    component: 'OracionModule',\n                    title: 'OraciÃ³n'\n                },\n                'oracion/adoracion': {\n                    path: '/practica/oracion/adoracion',\n                    component: 'OracionAdoracion',\n                    title: 'OraciÃ³n de AdoraciÃ³n'\n                },\n                'oracion/confesion': {\n                    path: '/practica/oracion/confesion',\n                    component: 'OracionConfesion',\n                    title: 'OraciÃ³n de ConfesiÃ³n'\n                },\n                'oracion/gratitud': {\n                    path: '/practica/oracion/gratitud',\n                    component: 'OracionGratitud',\n                    title: 'OraciÃ³n de Gratitud'\n                },\n                'oracion/peticion': {\n                    path: '/practica/oracion/peticion',\n                    component: 'OracionPeticion',\n                    title: 'OraciÃ³n de PeticiÃ³n'\n                },\n                'vida': {\n                    path: '/practica/vida',\n                    component: 'VidaModule',\n                    title: 'Vida Cristiana'\n                }\n            }\n        });\n        \n        // Rutas sociales\n        this.addRoute('social', {\n            path: '/social',\n            component: 'SocialSection',\n            title: 'Comunidad - BibliaApp Pro',\n            requiresAuth: false,\n            children: {\n                'comunidad': {\n                    path: '/social/comunidad',\n                    component: 'ComunidadModule',\n                    title: 'Comunidad'\n                },\n                'grupos': {\n                    path: '/social/grupos',\n                    component: 'GruposModule',\n                    title: 'Grupos de Estudio'\n                },\n                'eventos': {\n                    path: '/social/eventos',\n                    component: 'EventosModule',\n                    title: 'Eventos'\n                }\n            }\n        });\n        \n        // Rutas de herramientas\n        this.addRoute('herramientas', {\n            path: '/herramientas',\n            component: 'HerramientasSection',\n            title: 'Herramientas - BibliaApp Pro',\n            requiresAuth: false,\n            children: {\n                'hermeneutica': {\n                    path: '/herramientas/hermeneutica',\n                    component: 'HermeneuticaTools',\n                    title: 'Herramientas HermenÃ©uticas'\n                },\n                'linguistica': {\n                    path: '/herramientas/linguistica',\n                    component: 'LinguisticaTools',\n                    title: 'AnÃ¡lisis LingÃ¼Ã­stico'\n                },\n                'visualizacion': {\n                    path: '/herramientas/visualizacion',\n                    component: 'VisualizacionTools',\n                    title: 'Visualizaciones'\n                }\n            }\n        });\n        \n        // Rutas de configuraciÃ³n\n        this.addRoute('ajustes', {\n            path: '/ajustes',\n            component: 'AjustesSection',\n            title: 'ConfiguraciÃ³n - BibliaApp Pro',\n            requiresAuth: false,\n            children: {\n                'perfil': {\n                    path: '/ajustes/perfil',\n                    component: 'PerfilSettings',\n                    title: 'Perfil'\n                },\n                'personalizacion': {\n                    path: '/ajustes/personalizacion',\n                    component: 'PersonalizacionSettings',\n                    title: 'PersonalizaciÃ³n'\n                },\n                'notificaciones': {\n                    path: '/ajustes/notificaciones',\n                    component: 'NotificacionesSettings',\n                    title: 'Notificaciones'\n                },\n                'privacidad': {\n                    path: '/ajustes/privacidad',\n                    component: 'PrivacidadSettings',\n                    title: 'Privacidad'\n                }\n            }\n        });\n        \n        // Ruta 404\n        this.addRoute('404', {\n            path: '/404',\n            component: 'NotFoundPage',\n            title: 'PÃ¡gina no encontrada - BibliaApp Pro',\n            requiresAuth: false\n        });\n    }\n    \n    /**\n     * Agregar ruta\n     */\n    addRoute(name, config) {\n        this.routes.set(name, {\n            name,\n            ...config,\n            params: {},\n            query: {}\n        });\n    }\n    \n    /**\n     * Configurar event listeners\n     */\n    setupEventListeners() {\n        if (this.config.useHash) {\n            window.addEventListener('hashchange', this.handleHashChange);\n        } else {\n            window.addEventListener('popstate', this.handlePopState);\n        }\n        \n        // Interceptar clicks en enlaces\n        document.addEventListener('click', (e) => {\n            const link = e.target.closest('a[href]');\n            if (link && this.shouldInterceptLink(link)) {\n                e.preventDefault();\n                const href = link.getAttribute('href');\n                this.navigate(href);\n            }\n        });\n    }\n    \n    /**\n     * Verificar si debe interceptar el enlace\n     */\n    shouldInterceptLink(link) {\n        const href = link.getAttribute('href');\n        \n        // No interceptar enlaces externos\n        if (href.startsWith('http') || href.startsWith('mailto:') || href.startsWith('tel:')) {\n            return false;\n        }\n        \n        // No interceptar si tiene target=\"_blank\"\n        if (link.getAttribute('target') === '_blank') {\n            return false;\n        }\n        \n        // No interceptar si tiene data-no-route\n        if (link.hasAttribute('data-no-route')) {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Navegar a ruta inicial\n     */\n    navigateToInitialRoute() {\n        let initialRoute = this.config.defaultRoute;\n        \n        if (this.config.useHash) {\n            const hash = window.location.hash.slice(1); // Remover #\n            if (hash) {\n                initialRoute = this.getRouteFromPath(hash) || initialRoute;\n            }\n        } else {\n            const path = window.location.pathname;\n            initialRoute = this.getRouteFromPath(path) || initialRoute;\n        }\n        \n        this.navigate(initialRoute, { replace: true });\n    }\n    \n    /**\n     * Obtener ruta desde path\n     */\n    getRouteFromPath(path) {\n        // Limpiar path\n        path = path.replace(/^\/+|\/+$/g, '') || 'inicio';\n        \n        // Buscar coincidencia exacta\n        for (const [name, route] of this.routes) {\n            const routePath = route.path.replace(/^\/+|\/+$/g, '');\n            if (routePath === path) {\n                return name;\n            }\n        }\n        \n        // Buscar coincidencia parcial (para rutas anidadas)\n        const segments = path.split('/');\n        const mainSegment = segments[0];\n        \n        if (this.routes.has(mainSegment)) {\n            return mainSegment;\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Navegar a ruta\n     */\n    async navigate(routeOrPath, options = {}) {\n        if (this.navigating) {\n            console.warn('NavegaciÃ³n en progreso, ignorando nueva navegaciÃ³n');\n            return false;\n        }\n        \n        this.navigating = true;\n        \n        try {\n            // Resolver ruta\n            const route = this.resolveRoute(routeOrPath);\n            if (!route) {\n                console.warn(`Ruta no encontrada: ${routeOrPath}`);\n                this.navigating = false;\n                return this.navigate('404');\n            }\n            \n            // Verificar autenticaciÃ³n si es necesaria\n            if (route.requiresAuth && !this.isAuthenticated()) {\n                console.warn('Ruta requiere autenticaciÃ³n');\n                this.navigating = false;\n                return this.navigate('login');\n            }\n            \n            // Ejecutar guards de salida\n            if (this.currentRoute && !await this.executeLeaveGuards(this.currentRoute, route)) {\n                this.navigating = false;\n                return false;\n            }\n            \n            // Ejecutar guards de entrada\n            if (!await this.executeEnterGuards(route)) {\n                this.navigating = false;\n                return false;\n            }\n            \n            const previousRoute = this.currentRoute;\n            \n            // Actualizar historial\n            if (!options.replace) {\n                this.addToHistory(route);\n            }\n            \n            // Actualizar URL\n            this.updateURL(route, options.replace);\n            \n            // Actualizar tÃ­tulo\n            document.title = route.title || 'BibliaApp Pro';\n            \n            // Cargar componente\n            await this.loadComponent(route);\n            \n            // Actualizar ruta actual\n            this.currentRoute = route;\n            \n            // Emitir eventos\n            this.emit('route:before-change', { from: previousRoute, to: route });\n            this.emit('route:changed', { from: previousRoute, to: route });\n            \n            // Analytics\n            this.trackNavigation(route);\n            \n            console.log(`ðŸ§­ Navegado a: ${route.name}`);\n            return true;\n            \n        } catch (error) {\n            console.error('Error en navegaciÃ³n:', error);\n            this.emit('route:error', { error, route: routeOrPath });\n            return false;\n        } finally {\n            this.navigating = false;\n        }\n    }\n    \n    /**\n     * Resolver ruta\n     */\n    resolveRoute(routeOrPath) {\n        if (typeof routeOrPath === 'string') {\n            // Si es un nombre de ruta\n            if (this.routes.has(routeOrPath)) {\n                return this.routes.get(routeOrPath);\n            }\n            \n            // Si es un path\n            const routeName = this.getRouteFromPath(routeOrPath);\n            if (routeName) {\n                const route = { ...this.routes.get(routeName) };\n                \n                // Parsear parÃ¡metros y query\n                const { params, query } = this.parseURL(routeOrPath);\n                route.params = params;\n                route.query = query;\n                \n                return route;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Parsear URL para extraer parÃ¡metros\n     */\n    parseURL(path) {\n        const [pathname, queryString] = path.split('?');\n        \n        const params = {};\n        const query = {};\n        \n        // Parsear query string\n        if (queryString) {\n            const urlParams = new URLSearchParams(queryString);\n            for (const [key, value] of urlParams) {\n                query[key] = value;\n            }\n        }\n        \n        // TODO: Parsear parÃ¡metros de ruta (/user/:id)\n        \n        return { params, query };\n    }\n    \n    /**\n     * Cargar componente de la ruta\n     */\n    async loadComponent(route) {\n        try {\n            // En esta implementaciÃ³n, delegamos a UIManager\n            if (window.App && window.App.ui) {\n                // Extraer secciÃ³n principal del nombre de ruta\n                const section = route.name.split('/')[0];\n                await window.App.ui.showSection(section);\n                \n                // Si hay subsecciÃ³n, cargarla tambiÃ©n\n                if (route.name.includes('/')) {\n                    await this.loadSubsection(route);\n                }\n            }\n        } catch (error) {\n            console.error('Error cargando componente:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Cargar subsecciÃ³n\n     */\n    async loadSubsection(route) {\n        const subsection = route.name.split('/').slice(1).join('/');\n        \n        // Emitir evento para que otros mÃ³dulos manejen la subsecciÃ³n\n        this.emit('subsection:load', {\n            route,\n            subsection,\n            params: route.params,\n            query: route.query\n        });\n    }\n    \n    /**\n     * Ejecutar guards de entrada\n     */\n    async executeEnterGuards(route) {\n        if (route.beforeEnter) {\n            try {\n                const result = await route.beforeEnter(route);\n                return result !== false;\n            } catch (error) {\n                console.error('Error en guard de entrada:', error);\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Ejecutar guards de salida\n     */\n    async executeLeaveGuards(currentRoute, nextRoute) {\n        if (currentRoute.beforeLeave) {\n            try {\n                const result = await currentRoute.beforeLeave(currentRoute, nextRoute);\n                return result !== false;\n            } catch (error) {\n                console.error('Error en guard de salida:', error);\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Actualizar URL\n     */\n    updateURL(route, replace = false) {\n        const url = this.buildURL(route);\n        \n        if (this.config.useHash) {\n            const newHash = '#' + route.path.slice(1); // Remover / inicial\n            if (replace) {\n                window.location.replace(window.location.pathname + window.location.search + newHash);\n            } else {\n                window.location.hash = newHash;\n            }\n        } else {\n            if (replace) {\n                window.history.replaceState({ route: route.name }, route.title, url);\n            } else {\n                window.history.pushState({ route: route.name }, route.title, url);\n            }\n        }\n    }\n    \n    /**\n     * Construir URL completa\n     */\n    buildURL(route) {\n        let url = route.path;\n        \n        // Agregar query parameters\n        if (route.query && Object.keys(route.query).length > 0) {\n            const queryString = new URLSearchParams(route.query).toString();\n            url += '?' + queryString;\n        }\n        \n        return url;\n    }\n    \n    /**\n     * Agregar al historial\n     */\n    addToHistory(route) {\n        this.history.push(route);\n        \n        // Mantener tamaÃ±o mÃ¡ximo del historial\n        if (this.history.length > this.config.maxHistorySize) {\n            this.history.shift();\n        }\n    }\n    \n    /**\n     * Volver atrÃ¡s\n     */\n    goBack() {\n        if (this.canGoBack()) {\n            window.history.back();\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Ir adelante\n     */\n    goForward() {\n        window.history.forward();\n    }\n    \n    /**\n     * Verificar si puede volver atrÃ¡s\n     */\n    canGoBack() {\n        return this.history.length > 1;\n    }\n    \n    /**\n     * Obtener historial\n     */\n    getHistory() {\n        return [...this.history];\n    }\n    \n    /**\n     * Reemplazar ruta actual\n     */\n    replace(routeOrPath) {\n        return this.navigate(routeOrPath, { replace: true });\n    }\n    \n    /**\n     * Manejar cambios de hash\n     */\n    handleHashChange(event) {\n        const hash = window.location.hash.slice(1);\n        const route = this.getRouteFromPath(hash) || this.config.defaultRoute;\n        this.navigate(route, { replace: true });\n    }\n    \n    /**\n     * Manejar popstate\n     */\n    handlePopState(event) {\n        if (event.state && event.state.route) {\n            this.navigate(event.state.route, { replace: true });\n        } else {\n            const path = window.location.pathname;\n            const route = this.getRouteFromPath(path) || this.config.defaultRoute;\n            this.navigate(route, { replace: true });\n        }\n    }\n    \n    /**\n     * Verificar autenticaciÃ³n (placeholder)\n     */\n    isAuthenticated() {\n        // Por ahora retornamos true, pero aquÃ­ irÃ­a la lÃ³gica real\n        return true;\n    }\n    \n    /**\n     * Sistema de eventos\n     */\n    on(event, callback) {\n        if (!this.eventListeners) this.eventListeners = {};\n        if (!this.eventListeners[event]) this.eventListeners[event] = [];\n        this.eventListeners[event].push(callback);\n        \n        return () => this.off(event, callback);\n    }\n    \n    emit(event, data) {\n        if (!this.eventListeners || !this.eventListeners[event]) return;\n        \n        this.eventListeners[event].forEach(callback => {\n            try {\n                callback(data);\n            } catch (error) {\n                console.error(`Error en event listener para ${event}:`, error);\n            }\n        });\n    }\n    \n    off(event, callback) {\n        if (!this.eventListeners || !this.eventListeners[event]) return;\n        \n        const index = this.eventListeners[event].indexOf(callback);\n        if (index > -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n    \n    /**\n     * Analytics de navegaciÃ³n\n     */\n    trackNavigation(route) {\n        if (window.App && window.App.analytics) {\n            window.App.analytics.trackEvent('navigation', 'route_change', {\n                route: route.name,\n                path: route.path,\n                title: route.title,\n                timestamp: Date.now()\n            });\n        }\n    }\n    \n    /**\n     * Utilidades de navegaciÃ³n\n     */\n    \n    /**\n     * Generar URL para una ruta\n     */\n    url(routeName, params = {}, query = {}) {\n        const route = this.routes.get(routeName);\n        if (!route) {\n            console.warn(`Ruta no encontrada: ${routeName}`);\n            return '#';\n        }\n        \n        let path = route.path;\n        \n        // Reemplazar parÃ¡metros en el path\n        for (const [key, value] of Object.entries(params)) {\n            path = path.replace(`:${key}`, encodeURIComponent(value));\n        }\n        \n        // Agregar query string\n        if (Object.keys(query).length > 0) {\n            const queryString = new URLSearchParams(query).toString();\n            path += '?' + queryString;\n        }\n        \n        return this.config.useHash ? '#' + path.slice(1) : path;\n    }\n    \n    /**\n     * Verificar si una ruta estÃ¡ activa\n     */\n    isActive(routeName) {\n        if (!this.currentRoute) return false;\n        \n        return this.currentRoute.name === routeName || \n               this.currentRoute.name.startsWith(routeName + '/');\n    }\n    \n    /**\n     * Obtener ruta actual\n     */\n    getCurrentRoute() {\n        return this.currentRoute;\n    }\n    \n    /**\n     * Obtener todas las rutas\n     */\n    getRoutes() {\n        return new Map(this.routes);\n    }\n    \n    /**\n     * Verificar si el router estÃ¡ inicializado\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    \n    /**\n     * Limpiar router\n     */\n    destroy() {\n        // Remover event listeners\n        if (this.config.useHash) {\n            window.removeEventListener('hashchange', this.handleHashChange);\n        } else {\n            window.removeEventListener('popstate', this.handlePopState);\n        }\n        \n        // Limpiar estado\n        this.routes.clear();\n        this.history = [];\n        this.listeners = [];\n        this.currentRoute = null;\n        this.initialized = false;\n        \n        console.log('ðŸš¦ Router destruÃ­do');\n    }\n    \n    /**\n     * Configurar rutas dinÃ¡micamente\n     */\n    addDynamicRoute(name, config) {\n        this.addRoute(name, config);\n        console.log(`âž• Ruta dinÃ¡mica agregada: ${name}`);\n    }\n    \n    removeDynamicRoute(name) {\n        if (this.routes.has(name)) {\n            this.routes.delete(name);\n            console.log(`âž– Ruta dinÃ¡mica removida: ${name}`);\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Middleware para todas las rutas\n     */\n    useMiddleware(middleware) {\n        // Agregar middleware global\n        // TODO: Implementar sistema de middleware\n    }\n    \n    /**\n     * Prefetch de rutas\n     */\n    async prefetchRoute(routeName) {\n        const route = this.routes.get(routeName);\n        if (!route) return false;\n        \n        try {\n            // Precargar recursos de la ruta\n            if (route.preload) {\n                await this.preloadRouteResources(route);\n            }\n            \n            console.log(`ðŸš€ Ruta precargada: ${routeName}`);\n            return true;\n        } catch (error) {\n            console.error(`Error precargando ruta ${routeName}:`, error);\n            return false;\n        }\n    }\n    \n    async preloadRouteResources(route) {\n        // Implementar precarga de recursos\n        // Por ejemplo: precargar datos, componentes, etc.\n    }\n    \n    /**\n     * Breadcrumbs\n     */\n    getBreadcrumbs() {\n        if (!this.currentRoute) return [];\n        \n        const breadcrumbs = [];\n        const pathSegments = this.currentRoute.path.split('/').filter(Boolean);\n        \n        let currentPath = '';\n        for (const segment of pathSegments) {\n            currentPath += '/' + segment;\n            const routeName = this.getRouteFromPath(currentPath);\n            \n            if (routeName) {\n                const route = this.routes.get(routeName);\n                breadcrumbs.push({\n                    name: routeName,\n                    title: route.title,\n                    path: currentPath,\n                    active: currentPath === this.currentRoute.path\n                });\n            }\n        }\n        \n        return breadcrumbs;\n    }\n}\n\n// Exportar para uso global\nif (typeof window !== 'undefined') {\n    window.AppRouter = AppRouter;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = AppRouter;\n}\n