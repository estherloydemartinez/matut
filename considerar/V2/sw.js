/**
 * BibliaApp Pro - Service Worker
 * PWA Service Worker para funcionalidad offline
 */

const CACHE_NAME = 'bibliaapp-v2.0.0';
const OFFLINE_URL = '/offline.html';

// Recursos cr√≠ticos que siempre deben estar en cach√©
const CRITICAL_RESOURCES = [
    '/',
    '/index.html',
    '/assets/css/main.css',
    '/assets/css/components.css',
    '/assets/js/main.js',
    '/assets/js/core/app.js',
    '/assets/js/core/ui-manager.js',
    '/assets/js/core/router.js',
    '/assets/js/data/bible-data.js',
    '/manifest.json',
    OFFLINE_URL
];

// Recursos que se pueden cachear bajo demanda
const CACHEABLE_PATTERNS = [
    /\.css$/,
    /\.js$/,
    /\.png$/,
    /\.jpg$/,
    /\.jpeg$/,
    /\.svg$/,
    /\.woff2?$/,
    /\.ttf$/
];

// URLs que nunca deben ser cacheadas
const NEVER_CACHE_PATTERNS = [
    /\/api\//,
    /analytics/,
    /tracking/,
    /socket/
];

// ============================================================================
// INSTALACI√ìN DEL SERVICE WORKER
// ============================================================================

self.addEventListener('install', (event) => {
    console.log('üì¶ Service Worker: Instalando...');
    
    event.waitUntil(
        (async () => {
            try {\n                const cache = await caches.open(CACHE_NAME);\n                \n                // Intentar cachear recursos cr√≠ticos\n                console.log('üíæ Cacheando recursos cr√≠ticos...');\n                \n                const cachePromises = CRITICAL_RESOURCES.map(async (resource) => {\n                    try {\n                        const response = await fetch(resource);\n                        if (response.ok) {\n                            await cache.put(resource, response.clone());\n                            console.log(`‚úÖ Cacheado: ${resource}`);\n                        } else {\n                            console.warn(`‚ö†Ô∏è No se pudo cachear ${resource}: ${response.status}`);\n                        }\n                    } catch (error) {\n                        console.warn(`‚ö†Ô∏è Error cacheando ${resource}:`, error.message);\n                    }\n                });\n                \n                await Promise.allSettled(cachePromises);\n                \n                console.log('‚úÖ Service Worker instalado correctamente');\n                \n                // Tomar control inmediatamente\n                self.skipWaiting();\n                \n            } catch (error) {\n                console.error('‚ùå Error durante la instalaci√≥n del Service Worker:', error);\n            }\n        })()\n    );\n});\n\n// ============================================================================\n// ACTIVACI√ìN DEL SERVICE WORKER\n// ============================================================================\n\nself.addEventListener('activate', (event) => {\n    console.log('üöÄ Service Worker: Activando...');\n    \n    event.waitUntil(\n        (async () => {\n            try {\n                // Limpiar cach√©s antiguos\n                const cacheNames = await caches.keys();\n                const deletionPromises = cacheNames\n                    .filter(name => name !== CACHE_NAME)\n                    .map(name => {\n                        console.log(`üóëÔ∏è Eliminando cach√© antiguo: ${name}`);\n                        return caches.delete(name);\n                    });\n                \n                await Promise.all(deletionPromises);\n                \n                // Tomar control de todas las pesta√±as\n                await self.clients.claim();\n                \n                console.log('‚úÖ Service Worker activado correctamente');\n                \n            } catch (error) {\n                console.error('‚ùå Error durante la activaci√≥n del Service Worker:', error);\n            }\n        })()\n    );\n});\n\n// ============================================================================\n// INTERCEPTACI√ìN DE REQUESTS\n// ============================================================================\n\nself.addEventListener('fetch', (event) => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Ignorar requests que no deben ser cacheados\n    if (shouldNeverCache(url)) {\n        return;\n    }\n    \n    // Estrategia seg√∫n el tipo de request\n    if (request.method === 'GET') {\n        if (url.pathname.endsWith('.html') || url.pathname === '/') {\n            // P√°ginas HTML: Network First con fallback a cache\n            event.respondWith(handlePageRequest(request));\n        } else if (shouldCache(url)) {\n            // Recursos est√°ticos: Cache First\n            event.respondWith(handleStaticResource(request));\n        } else {\n            // Otros requests: Network First\n            event.respondWith(handleNetworkFirst(request));\n        }\n    }\n});\n\n// ============================================================================\n// ESTRATEGIAS DE CACH√â\n// ============================================================================\n\n/**\n * Manejar requests de p√°ginas HTML\n * Estrategia: Network First con fallback a cache y offline\n */\nasync function handlePageRequest(request) {\n    try {\n        // Intentar obtener de la red primero\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            // Cachear la respuesta exitosa\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n            return networkResponse;\n        }\n        \n        throw new Error(`Network response not ok: ${networkResponse.status}`);\n        \n    } catch (error) {\n        console.log('üåê Network fall√≥, intentando cach√©:', request.url);\n        \n        // Intentar obtener del cach√©\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Si no est√° en cach√©, mostrar p√°gina offline\n        console.log('üì± Mostrando p√°gina offline');\n        return caches.match(OFFLINE_URL) || createOfflineFallback();\n    }\n}\n\n/**\n * Manejar recursos est√°ticos\n * Estrategia: Cache First con fallback a network\n */\nasync function handleStaticResource(request) {\n    try {\n        // Intentar obtener del cach√© primero\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Si no est√° en cach√©, obtener de la red\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            // Cachear para uso futuro\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n        \n    } catch (error) {\n        console.log('‚ùå Recurso no disponible:', request.url);\n        \n        // Para recursos cr√≠ticos, intentar un fallback\n        if (request.url.includes('.css')) {\n            return createCSSFallback();\n        } else if (request.url.includes('.js')) {\n            return createJSFallback();\n        }\n        \n        // Para otros recursos, retornar error\n        return new Response('Resource not available', { status: 404 });\n    }\n}\n\n/**\n * Manejar otros requests\n * Estrategia: Network First\n */\nasync function handleNetworkFirst(request) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        // Cachear respuestas exitosas si es apropiado\n        if (networkResponse.ok && shouldCache(new URL(request.url))) {\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n        \n    } catch (error) {\n        // Intentar obtener del cach√© como fallback\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        throw error;\n    }\n}\n\n// ============================================================================\n// FUNCIONES DE UTILIDAD\n// ============================================================================\n\n/**\n * Verificar si una URL debe ser cacheada\n */\nfunction shouldCache(url) {\n    return CACHEABLE_PATTERNS.some(pattern => pattern.test(url.pathname));\n}\n\n/**\n * Verificar si una URL nunca debe ser cacheada\n */\nfunction shouldNeverCache(url) {\n    return NEVER_CACHE_PATTERNS.some(pattern => pattern.test(url.pathname));\n}\n\n/**\n * Crear respuesta de fallback offline\n */\nfunction createOfflineFallback() {\n    const offlineHTML = `\n        <!DOCTYPE html>\n        <html lang=\"es\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <title>Sin Conexi√≥n - BibliaApp Pro</title>\n            <style>\n                body {\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                    margin: 0;\n                    padding: 40px 20px;\n                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n                    color: white;\n                    text-align: center;\n                    min-height: 100vh;\n                    display: flex;\n                    flex-direction: column;\n                    justify-content: center;\n                    align-items: center;\n                }\n                .offline-container {\n                    max-width: 400px;\n                    background: rgba(255, 255, 255, 0.1);\n                    backdrop-filter: blur(10px);\n                    border-radius: 20px;\n                    padding: 40px;\n                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);\n                }\n                .offline-icon {\n                    font-size: 4rem;\n                    margin-bottom: 20px;\n                }\n                h1 {\n                    margin: 0 0 10px 0;\n                    font-size: 2rem;\n                    font-weight: 600;\n                }\n                p {\n                    margin: 0 0 30px 0;\n                    font-size: 1.1rem;\n                    opacity: 0.9;\n                    line-height: 1.5;\n                }\n                .retry-btn {\n                    background: white;\n                    color: #667eea;\n                    border: none;\n                    padding: 12px 24px;\n                    border-radius: 12px;\n                    font-size: 1rem;\n                    font-weight: 600;\n                    cursor: pointer;\n                    transition: transform 0.2s;\n                }\n                .retry-btn:hover {\n                    transform: translateY(-2px);\n                }\n                .features {\n                    margin-top: 30px;\n                    text-align: left;\n                }\n                .feature {\n                    margin: 10px 0;\n                    font-size: 0.9rem;\n                    opacity: 0.8;\n                }\n            </style>\n        </head>\n        <body>\n            <div class=\"offline-container\">\n                <div class=\"offline-icon\">üì±</div>\n                <h1>Sin Conexi√≥n</h1>\n                <p>No hay conexi√≥n a Internet, pero BibliaApp Pro sigue funcionando en modo offline.</p>\n                \n                <button class=\"retry-btn\" onclick=\"window.location.reload()\">\n                    üîÑ Reintentar Conexi√≥n\n                </button>\n                \n                <div class=\"features\">\n                    <div class=\"feature\">üìñ Acceso a contenido cacheado</div>\n                    <div class=\"feature\">üôè Funciones de oraci√≥n offline</div>\n                    <div class=\"feature\">üìù Notas guardadas localmente</div>\n                    <div class=\"feature\">‚≠ê Vers√≠culos favoritos disponibles</div>\n                </div>\n            </div>\n        </body>\n        </html>\n    `;\n    \n    return new Response(offlineHTML, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\n/**\n * Crear fallback CSS\n */\nfunction createCSSFallback() {\n    const fallbackCSS = `\n        /* Fallback CSS b√°sico */\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            margin: 0;\n            padding: 0;\n            background: #f8fafc;\n            color: #1f2937;\n        }\n        .app-container {\n            min-height: 100vh;\n            display: flex;\n            flex-direction: column;\n        }\n        .main-content {\n            flex: 1;\n            padding: 20px;\n        }\n    `;\n    \n    return new Response(fallbackCSS, {\n        headers: { 'Content-Type': 'text/css' }\n    });\n}\n\n/**\n * Crear fallback JS\n */\nfunction createJSFallback() {\n    const fallbackJS = `\n        // Fallback JS b√°sico\n        console.warn('Cargando fallback JavaScript - funcionalidad limitada');\n        \n        // Funcionalidad m√≠nima para navegaci√≥n\n        document.addEventListener('DOMContentLoaded', function() {\n            // Mostrar mensaje de funcionalidad limitada\n            const message = document.createElement('div');\n            message.style.cssText = '\n                position: fixed; top: 10px; right: 10px;\n                background: #fbbf24; color: #92400e;\n                padding: 12px; border-radius: 8px;\n                font-size: 14px; z-index: 1000;\n            ';\n            message.textContent = 'Funcionalidad limitada - sin conexi√≥n';\n            document.body.appendChild(message);\n            \n            setTimeout(() => message.remove(), 5000);\n        });\n    `;\n    \n    return new Response(fallbackJS, {\n        headers: { 'Content-Type': 'application/javascript' }\n    });\n}\n\n// ============================================================================\n// MANEJO DE MENSAJES\n// ============================================================================\n\nself.addEventListener('message', (event) => {\n    const { type, payload } = event.data;\n    \n    switch (type) {\n        case 'SKIP_WAITING':\n            self.skipWaiting();\n            break;\n            \n        case 'GET_CACHE_SIZE':\n            getCacheSize().then(size => {\n                event.ports[0].postMessage({ size });\n            });\n            break;\n            \n        case 'CLEAR_CACHE':\n            clearCache().then(success => {\n                event.ports[0].postMessage({ success });\n            });\n            break;\n            \n        case 'PREFETCH_RESOURCES':\n            if (payload && payload.urls) {\n                prefetchResources(payload.urls);\n            }\n            break;\n            \n        default:\n            console.log('Mensaje desconocido en Service Worker:', type);\n    }\n});\n\n// ============================================================================\n// FUNCIONES DE MANTENIMIENTO\n// ============================================================================\n\n/**\n * Obtener tama√±o del cach√©\n */\nasync function getCacheSize() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const requests = await cache.keys();\n        \n        let totalSize = 0;\n        for (const request of requests) {\n            const response = await cache.match(request);\n            if (response) {\n                const blob = await response.blob();\n                totalSize += blob.size;\n            }\n        }\n        \n        return {\n            bytes: totalSize,\n            mb: Math.round(totalSize / (1024 * 1024) * 100) / 100,\n            items: requests.length\n        };\n    } catch (error) {\n        console.error('Error obteniendo tama√±o del cach√©:', error);\n        return { bytes: 0, mb: 0, items: 0 };\n    }\n}\n\n/**\n * Limpiar cach√©\n */\nasync function clearCache() {\n    try {\n        const deleted = await caches.delete(CACHE_NAME);\n        console.log('üóëÔ∏è Cach√© limpiado:', deleted);\n        return deleted;\n    } catch (error) {\n        console.error('Error limpiando cach√©:', error);\n        return false;\n    }\n}\n\n/**\n * Precargar recursos\n */\nasync function prefetchResources(urls) {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        \n        const prefetchPromises = urls.map(async (url) => {\n            try {\n                const response = await fetch(url);\n                if (response.ok) {\n                    await cache.put(url, response);\n                    console.log(`üì¶ Precargado: ${url}`);\n                }\n            } catch (error) {\n                console.warn(`‚ö†Ô∏è Error precargando ${url}:`, error.message);\n            }\n        });\n        \n        await Promise.allSettled(prefetchPromises);\n        console.log('‚úÖ Precarga completada');\n        \n    } catch (error) {\n        console.error('Error en precarga:', error);\n    }\n}\n\n// ============================================================================\n// SINCRONIZACI√ìN EN SEGUNDO PLANO (Background Sync)\n// ============================================================================\n\nself.addEventListener('sync', (event) => {\n    console.log('üîÑ Background Sync:', event.tag);\n    \n    if (event.tag === 'background-sync') {\n        event.waitUntil(doBackgroundSync());\n    }\n});\n\n/**\n * Realizar sincronizaci√≥n en segundo plano\n */\nasync function doBackgroundSync() {\n    try {\n        // Sincronizar datos pendientes\n        console.log('üîÑ Ejecutando sincronizaci√≥n en segundo plano...');\n        \n        // Aqu√≠ ir√≠a la l√≥gica para sincronizar datos\n        // Por ejemplo, enviar an√°lisis pendientes, sincronizar progreso, etc.\n        \n        console.log('‚úÖ Sincronizaci√≥n completada');\n        \n    } catch (error) {\n        console.error('‚ùå Error en sincronizaci√≥n:', error);\n    }\n}\n\n// ============================================================================\n// NOTIFICACIONES PUSH\n// ============================================================================\n\nself.addEventListener('push', (event) => {\n    console.log('üì¨ Push notification recibida');\n    \n    let notificationData = {\n        title: 'BibliaApp Pro',\n        body: 'Tienes una nueva notificaci√≥n',\n        icon: '/assets/icons/icon-192x192.png',\n        badge: '/assets/icons/badge-72x72.png',\n        tag: 'default'\n    };\n    \n    if (event.data) {\n        try {\n            notificationData = { ...notificationData, ...event.data.json() };\n        } catch (error) {\n            console.error('Error parseando datos de push:', error);\n        }\n    }\n    \n    event.waitUntil(\n        self.registration.showNotification(notificationData.title, {\n            body: notificationData.body,\n            icon: notificationData.icon,\n            badge: notificationData.badge,\n            tag: notificationData.tag,\n            data: notificationData.data || {},\n            actions: notificationData.actions || [],\n            requireInteraction: notificationData.requireInteraction || false\n        })\n    );\n});\n\nself.addEventListener('notificationclick', (event) => {\n    console.log('üîî Notification clicked:', event.notification.tag);\n    \n    event.notification.close();\n    \n    // Abrir la aplicaci√≥n\n    event.waitUntil(\n        clients.openWindow('/').then(client => {\n            if (client) {\n                client.focus();\n            }\n        })\n    );\n});\n\n// ============================================================================\n// LOGGING Y DEBUG\n// ============================================================================\n\n// Solo en desarrollo\nif (self.location.hostname === 'localhost') {\n    console.log('üîß Service Worker en modo desarrollo');\n    \n    // Logs adicionales para debug\n    self.addEventListener('fetch', (event) => {\n        if (event.request.url.includes('localhost')) {\n            console.log('üåê Fetch interceptado:', event.request.url);\n        }\n    });\n}\n\nconsole.log('üöÄ Service Worker BibliaApp Pro cargado');\n