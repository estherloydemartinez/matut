/* ==========================================================================
   BIBLIAAPP PRO v3.0 - STATE MANAGER
   Centralized state management with reactive updates
   ========================================================================== */

import { deepClone, deepMerge, debounce } from './utils.js';
import { APP_CONFIG, STORAGE_KEYS } from './constants.js';
import storage from './storage.js';

// ==========================================
// STATE MANAGER CLASS
// ==========================================

class StateManager {
    constructor() {
        this.state = this.getInitialState();
        this.subscribers = new Map();
        this.middleware = [];
        this.history = [];
        this.maxHistorySize = 50;
        this.isHydrated = false;
        
        // Debounced save function
        this.debouncedSave = debounce(this.saveState.bind(this), 1000);
        
        this.initializeState();
    }
    
    /**
     * Get initial application state
     * @returns {Object}
     */
    getInitialState() {
        return {\n            // Application state\n            app: {\n                initialized: false,\n                loading: false,\n                error: null,\n                theme: 'dark',\n                sidebarCollapsed: false,\n                currentSection: 'teoria',\n                currentSubSection: 'lectura',\n                lastActivity: Date.now()\n            },\n            \n            // User state\n            user: {\n                profile: {\n                    name: 'Usuario',\n                    email: null,\n                    avatar: null,\n                    preferences: {\n                        language: 'es',\n                        bibleVersion: 'rv1960',\n                        fontSize: 'medium',\n                        autoplay: false,\n                        notifications: true\n                    }\n                },\n                progress: {\n                    level: 1,\n                    xp: 0,\n                    streak: 0,\n                    longestStreak: 0,\n                    achievements: [],\n                    stats: {\n                        totalStudyTime: 0,\n                        totalVersesRead: 0,\n                        totalVersesMemorized: 0,\n                        totalPrayerTime: 0,\n                        toolsUsed: 0,\n                        socialInteractions: 0\n                    }\n                },\n                settings: {\n                    privacy: {\n                        profileVisible: true,\n                        progressVisible: true,\n                        activityVisible: false\n                    },\n                    notifications: {\n                        dailyReminder: true,\n                        streakReminder: true,\n                        socialUpdates: true,\n                        achievementAlerts: true\n                    },\n                    study: {\n                        autoSave: true,\n                        highlightSharing: false,\n                        noteBackup: true,\n                        offlineMode: true\n                    }\n                }\n            },\n            \n            // Bible state\n            bible: {\n                currentReading: {\n                    version: 'rv1960',\n                    book: 'genesis',\n                    chapter: 1,\n                    verse: null,\n                    readingPlan: null,\n                    progress: 0\n                },\n                bookmarks: [],\n                highlights: [],\n                notes: [],\n                recentSearches: [],\n                readingHistory: []\n            },\n            \n            // SRS (Spaced Repetition System) state\n            srs: {\n                cards: [],\n                schedule: [],\n                stats: {\n                    totalCards: 0,\n                    newToday: 0,\n                    reviewToday: 0,\n                    completed: 0,\n                    accuracy: 0,\n                    averageTime: 0\n                },\n                session: {\n                    active: false,\n                    currentCard: null,\n                    startTime: null,\n                    cardsCompleted: 0,\n                    timeSpent: 0\n                },\n                settings: {\n                    dailyNewLimit: 20,\n                    dailyReviewLimit: 100,\n                    sessionTimeLimit: 30 // minutes\n                }\n            },\n            \n            // Agua system state\n            agua: {\n                elements: {\n                    valor: [],\n                    anadir: [],\n                    noAnadir: []\n                },\n                history: [],\n                stats: {\n                    totalElements: 0,\n                    totalMoves: 0,\n                    lastActivity: null\n                }\n            },\n            \n            // Analytical tools state\n            tools: {\n                activeFilters: [],\n                expandedCategories: [],\n                favoriteTools: [],\n                recentlyUsed: [],\n                usage: {}\n            },\n            \n            // Social state\n            social: {\n                communities: [],\n                discussions: [],\n                notifications: [],\n                friends: [],\n                activities: [],\n                settings: {\n                    visibility: 'friends',\n                    allowInvites: true,\n                    autoJoinDiscussions: false\n                }\n            },\n            \n            // UI state\n            ui: {\n                modals: {\n                    active: null,\n                    stack: []\n                },\n                notifications: [],\n                loading: {\n                    global: false,\n                    components: {}\n                },\n                errors: [],\n                connectivity: {\n                    online: navigator.onLine,\n                    lastOnline: Date.now(),\n                    syncPending: false\n                },\n                layout: {\n                    sidebarWidth: 256,\n                    contentPadding: 24,\n                    headerHeight: 64\n                }\n            }\n        };\n    }\n    \n    /**\n     * Initialize state manager\n     */\n    async initializeState() {\n        try {\n            // Load persisted state\n            await this.hydrateState();\n            \n            // Setup connectivity monitoring\n            this.setupConnectivityMonitoring();\n            \n            // Setup periodic saves\n            this.setupPeriodicSave();\n            \n            // Mark as initialized\n            this.setState('app.initialized', true);\n            \n            console.log('State manager initialized');\n        } catch (error) {\n            console.error('Failed to initialize state manager:', error);\n            this.setState('app.error', error.message);\n        }\n    }\n    \n    /**\n     * Hydrate state from storage\n     */\n    async hydrateState() {\n        try {\n            // Load user progress\n            const userProgress = await storage.getUserProgress();\n            if (userProgress) {\n                this.setState('user.progress', userProgress);\n            }\n            \n            // Load user settings\n            const userSettings = await storage.get(STORAGE_KEYS.userSettings);\n            if (userSettings) {\n                this.setState('user.settings', userSettings);\n            }\n            \n            // Load current reading\n            const currentReading = await storage.get(STORAGE_KEYS.currentReading);\n            if (currentReading) {\n                this.setState('bible.currentReading', currentReading);\n            }\n            \n            // Load bookmarks\n            const bookmarks = await storage.get(STORAGE_KEYS.bookmarks, []);\n            this.setState('bible.bookmarks', bookmarks);\n            \n            // Load highlights\n            const highlights = await storage.get(STORAGE_KEYS.highlights, []);\n            this.setState('bible.highlights', highlights);\n            \n            // Load notes\n            const notes = await storage.get(STORAGE_KEYS.notes, []);\n            this.setState('bible.notes', notes);\n            \n            // Load SRS data\n            const srsCards = await storage.getSRSCards();\n            this.setState('srs.cards', srsCards);\n            \n            const srsSchedule = await storage.get(STORAGE_KEYS.srsSchedule, []);\n            this.setState('srs.schedule', srsSchedule);\n            \n            const srsStats = await storage.get(STORAGE_KEYS.srsStats);\n            if (srsStats) {\n                this.setState('srs.stats', srsStats);\n            }\n            \n            // Load Agua elements\n            const aguaElements = await storage.getAguaElements();\n            this.setState('agua.elements', aguaElements);\n            \n            // Load social data\n            const communities = await storage.get(STORAGE_KEYS.communities, []);\n            this.setState('social.communities', communities);\n            \n            const socialActivity = await storage.get(STORAGE_KEYS.socialActivity, []);\n            this.setState('social.activities', socialActivity);\n            \n            this.isHydrated = true;\n            console.log('State hydrated from storage');\n        } catch (error) {\n            console.error('Failed to hydrate state:', error);\n        }\n    }\n    \n    /**\n     * Setup connectivity monitoring\n     */\n    setupConnectivityMonitoring() {\n        window.addEventListener('online', () => {\n            this.setState('ui.connectivity.online', true);\n            this.setState('ui.connectivity.lastOnline', Date.now());\n        });\n        \n        window.addEventListener('offline', () => {\n            this.setState('ui.connectivity.online', false);\n        });\n    }\n    \n    /**\n     * Setup periodic state saving\n     */\n    setupPeriodicSave() {\n        // Save state every 5 minutes\n        setInterval(() => {\n            this.saveState();\n        }, 5 * 60 * 1000);\n        \n        // Save state on page unload\n        window.addEventListener('beforeunload', () => {\n            this.saveState();\n        });\n    }\n    \n    // ==========================================\n    // CORE STATE METHODS\n    // ==========================================\n    \n    /**\n     * Get state value by path\n     * @param {string} path - Dot notation path (e.g., 'user.profile.name')\n     * @param {any} defaultValue - Default value if path doesn't exist\n     * @returns {any}\n     */\n    getState(path = null, defaultValue = null) {\n        if (!path) {\n            return deepClone(this.state);\n        }\n        \n        const keys = path.split('.');\n        let current = this.state;\n        \n        for (const key of keys) {\n            if (current && typeof current === 'object' && key in current) {\n                current = current[key];\n            } else {\n                return defaultValue;\n            }\n        }\n        \n        return deepClone(current);\n    }\n    \n    /**\n     * Set state value by path\n     * @param {string} path - Dot notation path\n     * @param {any} value - Value to set\n     * @param {Object} options - Options for state update\n     */\n    setState(path, value, options = {}) {\n        const {\n            silent = false,\n            addToHistory = true,\n            persist = true\n        } = options;\n        \n        // Save previous state for history\n        const previousState = addToHistory ? deepClone(this.state) : null;\n        \n        // Update state\n        const keys = path.split('.');\n        let current = this.state;\n        \n        for (let i = 0; i < keys.length - 1; i++) {\n            const key = keys[i];\n            if (!(key in current) || typeof current[key] !== 'object') {\n                current[key] = {};\n            }\n            current = current[key];\n        }\n        \n        const lastKey = keys[keys.length - 1];\n        const oldValue = current[lastKey];\n        current[lastKey] = value;\n        \n        // Add to history\n        if (addToHistory && previousState) {\n            this.addToHistory({\n                type: 'SET_STATE',\n                path,\n                oldValue,\n                newValue: value,\n                timestamp: Date.now(),\n                previousState\n            });\n        }\n        \n        // Update last activity\n        this.state.app.lastActivity = Date.now();\n        \n        // Notify subscribers\n        if (!silent) {\n            this.notifySubscribers(path, value, oldValue);\n        }\n        \n        // Persist to storage\n        if (persist && this.isHydrated) {\n            this.debouncedSave();\n        }\n    }\n    \n    /**\n     * Update state by merging with existing value\n     * @param {string} path - Dot notation path\n     * @param {Object} updates - Updates to merge\n     * @param {Object} options - Options for state update\n     */\n    updateState(path, updates, options = {}) {\n        const currentValue = this.getState(path, {});\n        const mergedValue = deepMerge(currentValue, updates);\n        this.setState(path, mergedValue, options);\n    }\n    \n    /**\n     * Remove state property\n     * @param {string} path - Dot notation path\n     * @param {Object} options - Options for state update\n     */\n    removeState(path, options = {}) {\n        const keys = path.split('.');\n        let current = this.state;\n        \n        for (let i = 0; i < keys.length - 1; i++) {\n            const key = keys[i];\n            if (!(key in current) || typeof current[key] !== 'object') {\n                return; // Path doesn't exist\n            }\n            current = current[key];\n        }\n        \n        const lastKey = keys[keys.length - 1];\n        if (lastKey in current) {\n            const oldValue = current[lastKey];\n            delete current[lastKey];\n            \n            if (!options.silent) {\n                this.notifySubscribers(path, undefined, oldValue);\n            }\n            \n            if (options.persist !== false && this.isHydrated) {\n                this.debouncedSave();\n            }\n        }\n    }\n    \n    /**\n     * Reset state to initial values\n     * @param {string} path - Optional path to reset (resets entire state if not provided)\n     */\n    resetState(path = null) {\n        const initialState = this.getInitialState();\n        \n        if (path) {\n            const initialValue = this.getState.call({ state: initialState }, path);\n            this.setState(path, initialValue);\n        } else {\n            this.state = initialState;\n            this.notifySubscribers('*', this.state);\n            this.debouncedSave();\n        }\n    }\n    \n    // ==========================================\n    // SUBSCRIPTION SYSTEM\n    // ==========================================\n    \n    /**\n     * Subscribe to state changes\n     * @param {string|Array} paths - Path(s) to watch\n     * @param {function} callback - Callback function\n     * @param {Object} options - Subscription options\n     * @returns {function} Unsubscribe function\n     */\n    subscribe(paths, callback, options = {}) {\n        const {\n            immediate = false,\n            once = false\n        } = options;\n        \n        const pathArray = Array.isArray(paths) ? paths : [paths];\n        const subscriptionId = Date.now() + Math.random();\n        \n        const subscription = {\n            id: subscriptionId,\n            paths: pathArray,\n            callback,\n            once,\n            options\n        };\n        \n        // Add to subscribers for each path\n        pathArray.forEach(path => {\n            if (!this.subscribers.has(path)) {\n                this.subscribers.set(path, new Set());\n            }\n            this.subscribers.get(path).add(subscription);\n        });\n        \n        // Call immediately if requested\n        if (immediate) {\n            pathArray.forEach(path => {\n                const value = this.getState(path);\n                try {\n                    callback(value, undefined, path);\n                } catch (error) {\n                    console.error('Subscription callback error:', error);\n                }\n            });\n        }\n        \n        // Return unsubscribe function\n        return () => {\n            pathArray.forEach(path => {\n                const pathSubscribers = this.subscribers.get(path);\n                if (pathSubscribers) {\n                    pathSubscribers.delete(subscription);\n                    if (pathSubscribers.size === 0) {\n                        this.subscribers.delete(path);\n                    }\n                }\n            });\n        };\n    }\n    \n    /**\n     * Notify subscribers of state changes\n     * @param {string} path - Changed path\n     * @param {any} newValue - New value\n     * @param {any} oldValue - Old value\n     */\n    notifySubscribers(path, newValue, oldValue) {\n        const pathsToNotify = new Set([path]);\n        \n        // Add parent paths\n        const parts = path.split('.');\n        for (let i = 1; i < parts.length; i++) {\n            pathsToNotify.add(parts.slice(0, i).join('.'));\n        }\n        \n        // Add wildcard\n        pathsToNotify.add('*');\n        \n        pathsToNotify.forEach(notifyPath => {\n            const pathSubscribers = this.subscribers.get(notifyPath);\n            if (pathSubscribers) {\n                pathSubscribers.forEach(subscription => {\n                    try {\n                        subscription.callback(newValue, oldValue, path);\n                        \n                        // Remove if it's a once subscription\n                        if (subscription.once) {\n                            pathSubscribers.delete(subscription);\n                        }\n                    } catch (error) {\n                        console.error('Subscription callback error:', error);\n                    }\n                });\n                \n                // Clean up empty subscription sets\n                if (pathSubscribers.size === 0) {\n                    this.subscribers.delete(notifyPath);\n                }\n            }\n        });\n    }\n    \n    // ==========================================\n    // COMPUTED VALUES\n    // ==========================================\n    \n    /**\n     * Create computed value that updates when dependencies change\n     * @param {function} computeFn - Function to compute value\n     * @param {Array} dependencies - Array of state paths to watch\n     * @returns {function} Function to get computed value\n     */\n    computed(computeFn, dependencies) {\n        let cachedValue;\n        let isValid = false;\n        \n        // Subscribe to dependencies\n        const unsubscribe = this.subscribe(dependencies, () => {\n            isValid = false;\n        });\n        \n        const getComputedValue = () => {\n            if (!isValid) {\n                const dependencyValues = dependencies.map(dep => this.getState(dep));\n                cachedValue = computeFn(...dependencyValues);\n                isValid = true;\n            }\n            return cachedValue;\n        };\n        \n        // Add cleanup function\n        getComputedValue.destroy = unsubscribe;\n        \n        return getComputedValue;\n    }\n    \n    // ==========================================\n    // ACTIONS AND MUTATIONS\n    // ==========================================\n    \n    /**\n     * Dispatch action through middleware\n     * @param {Object} action - Action object\n     * @returns {any}\n     */\n    dispatch(action) {\n        let result = action;\n        \n        // Run through middleware\n        for (const middleware of this.middleware) {\n            try {\n                result = middleware(result, this.state, this);\n                if (!result) break; // Middleware can cancel action\n            } catch (error) {\n                console.error('Middleware error:', error);\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Add middleware\n     * @param {function} middleware - Middleware function\n     */\n    addMiddleware(middleware) {\n        this.middleware.push(middleware);\n    }\n    \n    /**\n     * Remove middleware\n     * @param {function} middleware - Middleware function to remove\n     */\n    removeMiddleware(middleware) {\n        const index = this.middleware.indexOf(middleware);\n        if (index > -1) {\n            this.middleware.splice(index, 1);\n        }\n    }\n    \n    // ==========================================\n    // HISTORY AND TIME TRAVEL\n    // ==========================================\n    \n    /**\n     * Add entry to state history\n     * @param {Object} entry - History entry\n     */\n    addToHistory(entry) {\n        this.history.push(entry);\n        \n        // Limit history size\n        if (this.history.length > this.maxHistorySize) {\n            this.history.shift();\n        }\n    }\n    \n    /**\n     * Undo last state change\n     * @returns {boolean} Whether undo was successful\n     */\n    undo() {\n        if (this.history.length === 0) return false;\n        \n        const lastEntry = this.history.pop();\n        \n        if (lastEntry.type === 'SET_STATE') {\n            this.setState(lastEntry.path, lastEntry.oldValue, {\n                silent: false,\n                addToHistory: false,\n                persist: true\n            });\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Get state history\n     * @returns {Array}\n     */\n    getHistory() {\n        return [...this.history];\n    }\n    \n    /**\n     * Clear state history\n     */\n    clearHistory() {\n        this.history = [];\n    }\n    \n    // ==========================================\n    // PERSISTENCE\n    // ==========================================\n    \n    /**\n     * Save current state to storage\n     */\n    async saveState() {\n        if (!this.isHydrated) return;\n        \n        try {\n            // Save different parts of state to appropriate storage keys\n            await Promise.all([\n                storage.setUserProgress(this.state.user.progress),\n                storage.set(STORAGE_KEYS.userSettings, this.state.user.settings),\n                storage.set(STORAGE_KEYS.currentReading, this.state.bible.currentReading),\n                storage.set(STORAGE_KEYS.bookmarks, this.state.bible.bookmarks),\n                storage.set(STORAGE_KEYS.highlights, this.state.bible.highlights),\n                storage.set(STORAGE_KEYS.notes, this.state.bible.notes),\n                storage.setSRSCards(this.state.srs.cards),\n                storage.set(STORAGE_KEYS.srsSchedule, this.state.srs.schedule),\n                storage.set(STORAGE_KEYS.srsStats, this.state.srs.stats),\n                storage.setAguaElements(this.state.agua.elements),\n                storage.set(STORAGE_KEYS.communities, this.state.social.communities),\n                storage.set(STORAGE_KEYS.socialActivity, this.state.social.activities)\n            ]);\n            \n            console.log('State saved to storage');\n        } catch (error) {\n            console.error('Failed to save state:', error);\n        }\n    }\n    \n    /**\n     * Export state as JSON\n     * @param {Array} excludePaths - Paths to exclude from export\n     * @returns {string}\n     */\n    exportState(excludePaths = ['ui', 'app.error']) {\n        const exportedState = deepClone(this.state);\n        \n        // Remove excluded paths\n        excludePaths.forEach(path => {\n            const keys = path.split('.');\n            let current = exportedState;\n            \n            for (let i = 0; i < keys.length - 1; i++) {\n                if (current && typeof current === 'object' && keys[i] in current) {\n                    current = current[keys[i]];\n                } else {\n                    return; // Path doesn't exist\n                }\n            }\n            \n            const lastKey = keys[keys.length - 1];\n            if (current && typeof current === 'object' && lastKey in current) {\n                delete current[lastKey];\n            }\n        });\n        \n        return JSON.stringify(exportedState, null, 2);\n    }\n    \n    /**\n     * Import state from JSON\n     * @param {string} jsonState - JSON state string\n     * @param {boolean} merge - Whether to merge with existing state\n     */\n    importState(jsonState, merge = true) {\n        try {\n            const importedState = JSON.parse(jsonState);\n            \n            if (merge) {\n                this.state = deepMerge(this.state, importedState);\n            } else {\n                this.state = { ...this.getInitialState(), ...importedState };\n            }\n            \n            this.notifySubscribers('*', this.state);\n            this.debouncedSave();\n            \n            console.log('State imported successfully');\n        } catch (error) {\n            console.error('Failed to import state:', error);\n            throw new Error('Invalid state format');\n        }\n    }\n    \n    // ==========================================\n    // UTILITY METHODS\n    // ==========================================\n    \n    /**\n     * Get state size in bytes\n     * @returns {number}\n     */\n    getStateSize() {\n        return JSON.stringify(this.state).length;\n    }\n    \n    /**\n     * Get state statistics\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            stateSize: this.getStateSize(),\n            subscriberCount: Array.from(this.subscribers.values())\n                .reduce((total, set) => total + set.size, 0),\n            historyLength: this.history.length,\n            middlewareCount: this.middleware.length,\n            lastActivity: this.state.app.lastActivity,\n            isHydrated: this.isHydrated\n        };\n    }\n    \n    /**\n     * Debug method to log current state\n     * @param {string} filter - Optional filter for state paths\n     */\n    debug(filter = null) {\n        const state = filter ? this.getState(filter) : this.state;\n        console.group('🔍 State Debug');\n        console.log('Current state:', state);\n        console.log('Statistics:', this.getStats());\n        console.log('Subscribers:', this.subscribers);\n        console.log('History:', this.history.slice(-5)); // Last 5 entries\n        console.groupEnd();\n    }\n}\n\n// ==========================================\n// CREATE AND EXPORT STATE MANAGER INSTANCE\n// ==========================================\n\nconst stateManager = new StateManager();\n\n// Export convenience methods\nexport const getState = stateManager.getState.bind(stateManager);\nexport const setState = stateManager.setState.bind(stateManager);\nexport const updateState = stateManager.updateState.bind(stateManager);\nexport const subscribe = stateManager.subscribe.bind(stateManager);\nexport const dispatch = stateManager.dispatch.bind(stateManager);\nexport const computed = stateManager.computed.bind(stateManager);\n\nexport default stateManager;\nexport { StateManager };"