/* ==========================================================================\n   BIBLIAAPP PRO v3.0 - SERVICE WORKER\n   Enhanced PWA functionality with offline support and background sync\n   ========================================================================== */\n\nconst CACHE_NAME = 'bibliaapp-pro-v3.0.0';\nconst CACHE_VERSION = '3.0.0';\n\n// Cache strategy configuration\nconst CACHE_STRATEGIES = {\n    NETWORK_FIRST: 'network-first',\n    CACHE_FIRST: 'cache-first',\n    STALE_WHILE_REVALIDATE: 'stale-while-revalidate'\n};\n\n// Assets to cache immediately\nconst STATIC_ASSETS = [\n    '/',\n    '/index.html',\n    '/assets/css/core.css',\n    '/assets/css/components.css',\n    '/assets/css/animations.css',\n    '/assets/js/app-enhanced.js',\n    '/assets/js/core/constants.js',\n    '/assets/js/core/utils.js',\n    '/assets/js/core/storage.js',\n    '/assets/js/core/state-manager.js',\n    '/assets/js/core/ui-manager.js',\n    '/assets/js/modules/srs-system.js',\n    '/assets/js/modules/agua-system.js',\n    '/assets/js/modules/filters-system.js',\n    '/assets/js/modules/bible-data-enhanced.js',\n    '/assets/js/modules/social-system-enhanced.js',\n    '/assets/js/modules/analytical-tools-enhanced.js'\n];\n\n// Dynamic cache patterns\nconst CACHE_PATTERNS = {\n    api: {\n        pattern: /\\/api\\//,\n        strategy: CACHE_STRATEGIES.NETWORK_FIRST,\n        maxAge: 5 * 60 * 1000 // 5 minutes\n    },\n    images: {\n        pattern: /\\.(png|jpg|jpeg|gif|webp|svg)$/,\n        strategy: CACHE_STRATEGIES.CACHE_FIRST,\n        maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days\n    },\n    fonts: {\n        pattern: /\\.(woff|woff2|ttf|eot)$/,\n        strategy: CACHE_STRATEGIES.CACHE_FIRST,\n        maxAge: 90 * 24 * 60 * 60 * 1000 // 90 days\n    },\n    cdn: {\n        pattern: /^https:\\/\\/(cdn|fonts)\\./,\n        strategy: CACHE_STRATEGIES.STALE_WHILE_REVALIDATE,\n        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days\n    }\n};\n\n// Background sync configuration\nconst SYNC_TAGS = {\n    BIBLE_DATA: 'bible-data-sync',\n    USER_PROGRESS: 'user-progress-sync',\n    ANALYTICS: 'analytics-sync',\n    SOCIAL_DATA: 'social-data-sync'\n};\n\n// ==========================================\n// SERVICE WORKER EVENT HANDLERS\n// ==========================================\n\n/**\n * Install event - cache static assets\n */\nself.addEventListener('install', (event) => {\n    console.log('📦 SW: Installing service worker v' + CACHE_VERSION);\n    \n    event.waitUntil(\n        caches.open(CACHE_NAME).then((cache) => {\n            console.log('📋 SW: Caching static assets');\n            return cache.addAll(STATIC_ASSETS);\n        }).then(() => {\n            console.log('✅ SW: Installation complete');\n            // Force immediate activation\n            return self.skipWaiting();\n        }).catch((error) => {\n            console.error('❌ SW: Installation failed:', error);\n        })\n    );\n});\n\n/**\n * Activate event - clean up old caches\n */\nself.addEventListener('activate', (event) => {\n    console.log('🔄 SW: Activating service worker v' + CACHE_VERSION);\n    \n    event.waitUntil(\n        Promise.all([\n            // Clean up old caches\n            caches.keys().then((cacheNames) => {\n                return Promise.all(\n                    cacheNames\n                        .filter(cacheName => cacheName !== CACHE_NAME)\n                        .map(cacheName => {\n                            console.log('🗑️ SW: Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        })\n                );\n            }),\n            // Take control of all clients\n            self.clients.claim()\n        ]).then(() => {\n            console.log('✅ SW: Activation complete');\n        })\n    );\n});\n\n/**\n * Fetch event - handle network requests with caching strategies\n */\nself.addEventListener('fetch', (event) => {\n    // Skip non-GET requests\n    if (event.request.method !== 'GET') {\n        return;\n    }\n    \n    // Skip chrome-extension requests\n    if (event.request.url.startsWith('chrome-extension://')) {\n        return;\n    }\n    \n    const url = new URL(event.request.url);\n    \n    // Handle different types of requests\n    if (url.origin === location.origin) {\n        // Same-origin requests\n        event.respondWith(handleSameOriginRequest(event.request));\n    } else {\n        // Cross-origin requests (CDN, external APIs)\n        event.respondWith(handleCrossOriginRequest(event.request));\n    }\n});\n\n/**\n * Message event - handle messages from main app\n */\nself.addEventListener('message', (event) => {\n    const { type, data } = event.data;\n    \n    console.log('📬 SW: Received message:', type);\n    \n    switch (type) {\n        case 'SKIP_WAITING':\n            self.skipWaiting();\n            break;\n            \n        case 'CACHE_BIBLE_DATA':\n            cacheBibleData(data);\n            break;\n            \n        case 'CACHE_USER_DATA':\n            cacheUserData(data);\n            break;\n            \n        case 'CLEAR_CACHE':\n            clearAllCaches();\n            break;\n            \n        case 'GET_CACHE_SIZE':\n            getCacheSize().then(size => {\n                event.ports[0].postMessage({ type: 'CACHE_SIZE', size });\n            });\n            break;\n            \n        default:\n            console.warn('SW: Unknown message type:', type);\n    }\n});\n\n/**\n * Background sync event\n */\nself.addEventListener('sync', (event) => {\n    console.log('🔄 SW: Background sync triggered:', event.tag);\n    \n    switch (event.tag) {\n        case SYNC_TAGS.BIBLE_DATA:\n            event.waitUntil(syncBibleData());\n            break;\n            \n        case SYNC_TAGS.USER_PROGRESS:\n            event.waitUntil(syncUserProgress());\n            break;\n            \n        case SYNC_TAGS.ANALYTICS:\n            event.waitUntil(syncAnalytics());\n            break;\n            \n        case SYNC_TAGS.SOCIAL_DATA:\n            event.waitUntil(syncSocialData());\n            break;\n            \n        default:\n            console.warn('SW: Unknown sync tag:', event.tag);\n    }\n});\n\n/**\n * Push event - handle push notifications\n */\nself.addEventListener('push', (event) => {\n    console.log('📱 SW: Push notification received');\n    \n    const options = {\n        body: 'Tienes nuevas actualizaciones en BibliaApp Pro',\n        icon: '/assets/images/icon-192.png',\n        badge: '/assets/images/badge.png',\n        data: {\n            url: '/'\n        },\n        actions: [\n            {\n                action: 'open',\n                title: 'Abrir App'\n            },\n            {\n                action: 'dismiss',\n                title: 'Descartar'\n            }\n        ]\n    };\n    \n    if (event.data) {\n        const payload = event.data.json();\n        options.body = payload.body || options.body;\n        options.data = payload.data || options.data;\n    }\n    \n    event.waitUntil(\n        self.registration.showNotification('BibliaApp Pro', options)\n    );\n});\n\n/**\n * Notification click event\n */\nself.addEventListener('notificationclick', (event) => {\n    console.log('🔔 SW: Notification clicked:', event.action);\n    \n    event.notification.close();\n    \n    if (event.action === 'open' || !event.action) {\n        // Open the app\n        event.waitUntil(\n            clients.matchAll({ type: 'window' }).then((clientList) => {\n                // If app is already open, focus it\n                for (const client of clientList) {\n                    if (client.url === '/' && 'focus' in client) {\n                        return client.focus();\n                    }\n                }\n                \n                // Otherwise, open new window\n                if (clients.openWindow) {\n                    return clients.openWindow('/');\n                }\n            })\n        );\n    }\n});\n\n// ==========================================\n// CACHING STRATEGIES\n// ==========================================\n\n/**\n * Handle same-origin requests\n * @param {Request} request - The request\n * @returns {Promise<Response>} Response\n */\nasync function handleSameOriginRequest(request) {\n    const url = new URL(request.url);\n    \n    // HTML pages - network first with cache fallback\n    if (url.pathname.endsWith('.html') || url.pathname === '/') {\n        return networkFirstStrategy(request);\n    }\n    \n    // Static assets - cache first\n    if (isStaticAsset(url.pathname)) {\n        return cacheFirstStrategy(request);\n    }\n    \n    // API requests - network first with cache fallback\n    if (url.pathname.startsWith('/api/')) {\n        return networkFirstStrategy(request, CACHE_PATTERNS.api.maxAge);\n    }\n    \n    // Default - network first\n    return networkFirstStrategy(request);\n}\n\n/**\n * Handle cross-origin requests\n * @param {Request} request - The request\n * @returns {Promise<Response>} Response\n */\nasync function handleCrossOriginRequest(request) {\n    const url = new URL(request.url);\n    \n    // Check cache patterns\n    for (const [key, pattern] of Object.entries(CACHE_PATTERNS)) {\n        if (pattern.pattern.test(url.href)) {\n            switch (pattern.strategy) {\n                case CACHE_STRATEGIES.CACHE_FIRST:\n                    return cacheFirstStrategy(request, pattern.maxAge);\n                case CACHE_STRATEGIES.NETWORK_FIRST:\n                    return networkFirstStrategy(request, pattern.maxAge);\n                case CACHE_STRATEGIES.STALE_WHILE_REVALIDATE:\n                    return staleWhileRevalidateStrategy(request, pattern.maxAge);\n            }\n        }\n    }\n    \n    // Default - network only for cross-origin\n    return fetch(request);\n}\n\n/**\n * Network first strategy\n * @param {Request} request - The request\n * @param {number} maxAge - Maximum cache age in milliseconds\n * @returns {Promise<Response>} Response\n */\nasync function networkFirstStrategy(request, maxAge = null) {\n    try {\n        const response = await fetch(request);\n        \n        // Cache successful responses\n        if (response.status === 200) {\n            const cache = await caches.open(CACHE_NAME);\n            const responseToCache = response.clone();\n            \n            // Add timestamp for cache expiration\n            if (maxAge) {\n                const headers = new Headers(responseToCache.headers);\n                headers.set('sw-cached-at', Date.now().toString());\n                headers.set('sw-max-age', maxAge.toString());\n                \n                const cachedResponse = new Response(responseToCache.body, {\n                    status: responseToCache.status,\n                    statusText: responseToCache.statusText,\n                    headers\n                });\n                \n                await cache.put(request, cachedResponse);\n            } else {\n                await cache.put(request, responseToCache);\n            }\n        }\n        \n        return response;\n    } catch (error) {\n        console.log('🌐 SW: Network failed, trying cache:', request.url);\n        \n        // Try cache as fallback\n        const cachedResponse = await getCachedResponse(request, maxAge);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // If no cache, return offline page or error\n        if (request.destination === 'document') {\n            return getOfflinePage();\n        }\n        \n        throw error;\n    }\n}\n\n/**\n * Cache first strategy\n * @param {Request} request - The request\n * @param {number} maxAge - Maximum cache age in milliseconds\n * @returns {Promise<Response>} Response\n */\nasync function cacheFirstStrategy(request, maxAge = null) {\n    // Try cache first\n    const cachedResponse = await getCachedResponse(request, maxAge);\n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    // If not in cache, fetch from network\n    try {\n        const response = await fetch(request);\n        \n        // Cache successful responses\n        if (response.status === 200) {\n            const cache = await caches.open(CACHE_NAME);\n            await cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        console.error('SW: Cache first strategy failed:', error);\n        throw error;\n    }\n}\n\n/**\n * Stale while revalidate strategy\n * @param {Request} request - The request\n * @param {number} maxAge - Maximum cache age in milliseconds\n * @returns {Promise<Response>} Response\n */\nasync function staleWhileRevalidateStrategy(request, maxAge = null) {\n    const cache = await caches.open(CACHE_NAME);\n    const cachedResponse = await getCachedResponse(request, maxAge);\n    \n    // Start fetch in background\n    const fetchPromise = fetch(request).then(response => {\n        if (response.status === 200) {\n            cache.put(request, response.clone());\n        }\n        return response;\n    }).catch(error => {\n        console.warn('SW: Background fetch failed:', error);\n    });\n    \n    // Return cached response immediately if available\n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    // Otherwise wait for network\n    return fetchPromise;\n}\n\n/**\n * Get cached response with expiration check\n * @param {Request} request - The request\n * @param {number} maxAge - Maximum cache age in milliseconds\n * @returns {Promise<Response|null>} Cached response or null\n */\nasync function getCachedResponse(request, maxAge = null) {\n    const cache = await caches.open(CACHE_NAME);\n    const cachedResponse = await cache.match(request);\n    \n    if (!cachedResponse) {\n        return null;\n    }\n    \n    // Check expiration if maxAge is specified\n    if (maxAge) {\n        const cachedAt = cachedResponse.headers.get('sw-cached-at');\n        const cacheMaxAge = cachedResponse.headers.get('sw-max-age');\n        \n        if (cachedAt && cacheMaxAge) {\n            const age = Date.now() - parseInt(cachedAt);\n            const maxAgeValue = parseInt(cacheMaxAge);\n            \n            if (age > maxAgeValue) {\n                // Cache expired, remove it\n                await cache.delete(request);\n                return null;\n            }\n        }\n    }\n    \n    return cachedResponse;\n}\n\n/**\n * Get offline page\n * @returns {Promise<Response>} Offline page response\n */\nasync function getOfflinePage() {\n    const offlineHtml = `\n        <!DOCTYPE html>\n        <html lang=\"es\" class=\"dark\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <title>BibliaApp Pro - Offline</title>\n            <style>\n                body {\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                    background: #2f3136;\n                    color: #ffffff;\n                    margin: 0;\n                    padding: 0;\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    min-height: 100vh;\n                }\n                .offline-container {\n                    text-align: center;\n                    max-width: 400px;\n                    padding: 2rem;\n                }\n                .offline-icon {\n                    font-size: 4rem;\n                    margin-bottom: 1rem;\n                }\n                h1 {\n                    margin-bottom: 1rem;\n                    color: #ffffff;\n                }\n                p {\n                    color: #b9bbbe;\n                    margin-bottom: 2rem;\n                    line-height: 1.5;\n                }\n                button {\n                    background: #5865f2;\n                    color: white;\n                    border: none;\n                    padding: 0.75rem 1.5rem;\n                    border-radius: 0.5rem;\n                    font-size: 1rem;\n                    cursor: pointer;\n                    transition: background 0.2s;\n                }\n                button:hover {\n                    background: #4752c4;\n                }\n            </style>\n        </head>\n        <body>\n            <div class=\"offline-container\">\n                <div class=\"offline-icon\">📱</div>\n                <h1>Sin conexión</h1>\n                <p>BibliaApp Pro está funcionando en modo offline. Tus datos se sincronizarán cuando se restablezca la conexión.</p>\n                <button onclick=\"window.location.reload()\">Reintentar</button>\n            </div>\n        </body>\n        </html>\n    `;\n    \n    return new Response(offlineHtml, {\n        status: 200,\n        statusText: 'OK',\n        headers: {\n            'Content-Type': 'text/html'\n        }\n    });\n}\n\n// ==========================================\n// UTILITY FUNCTIONS\n// ==========================================\n\n/**\n * Check if path is a static asset\n * @param {string} pathname - URL pathname\n * @returns {boolean} True if static asset\n */\nfunction isStaticAsset(pathname) {\n    return STATIC_ASSETS.some(asset => {\n        // Remove leading slash for comparison\n        const assetPath = asset.startsWith('/') ? asset.slice(1) : asset;\n        const testPath = pathname.startsWith('/') ? pathname.slice(1) : pathname;\n        return assetPath === testPath || testPath.startsWith('assets/');\n    });\n}\n\n/**\n * Cache Bible data\n * @param {Object} data - Bible data to cache\n */\nasync function cacheBibleData(data) {\n    try {\n        const cache = await caches.open(CACHE_NAME + '-bible-data');\n        const response = new Response(JSON.stringify(data), {\n            headers: { 'Content-Type': 'application/json' }\n        });\n        await cache.put('/bible-data', response);\n        console.log('📖 SW: Bible data cached');\n    } catch (error) {\n        console.error('SW: Failed to cache Bible data:', error);\n    }\n}\n\n/**\n * Cache user data\n * @param {Object} data - User data to cache\n */\nasync function cacheUserData(data) {\n    try {\n        const cache = await caches.open(CACHE_NAME + '-user-data');\n        const response = new Response(JSON.stringify(data), {\n            headers: { 'Content-Type': 'application/json' }\n        });\n        await cache.put('/user-data', response);\n        console.log('👤 SW: User data cached');\n    } catch (error) {\n        console.error('SW: Failed to cache user data:', error);\n    }\n}\n\n/**\n * Clear all caches\n */\nasync function clearAllCaches() {\n    try {\n        const cacheNames = await caches.keys();\n        await Promise.all(\n            cacheNames.map(cacheName => caches.delete(cacheName))\n        );\n        console.log('🗑️ SW: All caches cleared');\n    } catch (error) {\n        console.error('SW: Failed to clear caches:', error);\n    }\n}\n\n/**\n * Get total cache size\n * @returns {Promise<number>} Cache size in bytes\n */\nasync function getCacheSize() {\n    let totalSize = 0;\n    \n    try {\n        const cacheNames = await caches.keys();\n        \n        for (const cacheName of cacheNames) {\n            const cache = await caches.open(cacheName);\n            const requests = await cache.keys();\n            \n            for (const request of requests) {\n                const response = await cache.match(request);\n                if (response) {\n                    const blob = await response.blob();\n                    totalSize += blob.size;\n                }\n            }\n        }\n    } catch (error) {\n        console.error('SW: Failed to calculate cache size:', error);\n    }\n    \n    return totalSize;\n}\n\n// ==========================================\n// BACKGROUND SYNC FUNCTIONS\n// ==========================================\n\n/**\n * Sync Bible data\n */\nasync function syncBibleData() {\n    try {\n        console.log('📖 SW: Syncing Bible data...');\n        // Implementation would sync with server\n        // For now, just log the action\n        console.log('✅ SW: Bible data sync completed');\n    } catch (error) {\n        console.error('SW: Bible data sync failed:', error);\n        throw error;\n    }\n}\n\n/**\n * Sync user progress\n */\nasync function syncUserProgress() {\n    try {\n        console.log('📊 SW: Syncing user progress...');\n        // Implementation would sync with server\n        console.log('✅ SW: User progress sync completed');\n    } catch (error) {\n        console.error('SW: User progress sync failed:', error);\n        throw error;\n    }\n}\n\n/**\n * Sync analytics data\n */\nasync function syncAnalytics() {\n    try {\n        console.log('📈 SW: Syncing analytics...');\n        // Implementation would sync with analytics service\n        console.log('✅ SW: Analytics sync completed');\n    } catch (error) {\n        console.error('SW: Analytics sync failed:', error);\n        throw error;\n    }\n}\n\n/**\n * Sync social data\n */\nasync function syncSocialData() {\n    try {\n        console.log('👥 SW: Syncing social data...');\n        // Implementation would sync with social features backend\n        console.log('✅ SW: Social data sync completed');\n    } catch (error) {\n        console.error('SW: Social data sync failed:', error);\n        throw error;\n    }\n}\n\n// ==========================================\n// SERVICE WORKER READY\n// ==========================================\n\nconsole.log('📱 BibliaApp Pro Service Worker v' + CACHE_VERSION + ' loaded');"
