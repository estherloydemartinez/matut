/* ==========================================================================
   BIBLIAAPP PRO v3.0 - SRS SYSTEM MODULE
   Advanced Spaced Repetition System for verse memorization
   ========================================================================== */

import { $, $$, createElement, debounce, formatRelativeTime, stringSimilarity } from './utils.js';
import { SRS_CONFIG, GAMIFICATION_CONFIG } from './constants.js';
import stateManager, { getState, setState, updateState, subscribe } from './state-manager.js';
import uiManager from './ui-manager.js';

// ==========================================
// SRS SYSTEM CLASS
// ==========================================

class SRSSystem {
    constructor() {
        this.cards = [];\n        this.schedule = [];\n        this.currentSession = null;\n        this.isInitialized = false;\n        \n        this.initializeSystem();\n    }\n    \n    /**\n     * Initialize SRS System\n     */\n    async initializeSystem() {\n        try {\n            // Load existing cards and schedule\n            await this.loadData();\n            \n            // Setup UI components\n            this.setupSRSInterface();\n            \n            // Setup state subscriptions\n            this.setupStateSubscriptions();\n            \n            // Schedule daily maintenance\n            this.scheduleDailyMaintenance();\n            \n            this.isInitialized = true;\n            console.log('SRS System initialized with', this.cards.length, 'cards');\n            \n        } catch (error) {\n            console.error('Failed to initialize SRS System:', error);\n        }\n    }\n    \n    /**\n     * Load SRS data from state\n     */\n    async loadData() {\n        this.cards = getState('srs.cards', []);\n        this.schedule = getState('srs.schedule', []);\n        \n        // Update today's schedule\n        this.updateDailySchedule();\n    }\n    \n    /**\n     * Setup SRS interface\n     */\n    setupSRSInterface() {\n        this.setupMemorizationUI();\n        this.setupStatsDisplay();\n        this.bindEventListeners();\n    }\n    \n    /**\n     * Setup memorization UI components\n     */\n    setupMemorizationUI() {\n        const memorizationContainer = $('#subcontent-memorizacion');\n        if (!memorizationContainer) return;\n        \n        // Citation button\n        const citationButton = $('#citation');\n        if (citationButton) {\n            citationButton.addEventListener('click', () => {\n                this.revealVerse();\n            });\n        }\n        \n        // Input area\n        this.verseInput = $('#verseInput');\n        if (this.verseInput) {\n            this.verseInput.addEventListener('input', debounce(() => {\n                this.handleInputChange();\n            }, 300));\n        }\n        \n        // Action buttons\n        const revealBtn = $('#revealBtn');\n        if (revealBtn) {\n            revealBtn.addEventListener('click', () => {\n                this.revealVerse();\n            });\n        }\n        \n        const checkBtn = $('#checkBtn');\n        if (checkBtn) {\n            checkBtn.addEventListener('click', () => {\n                this.checkAnswer();\n            });\n        }\n        \n        // Rating buttons\n        const ratingButtons = $$('.srs-rating-btn');\n        ratingButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                const rating = parseInt(button.dataset.rating);\n                this.submitRating(rating);\n            });\n        });\n        \n        // Load first card\n        this.loadNextCard();\n    }\n    \n    /**\n     * Setup statistics display\n     */\n    setupStatsDisplay() {\n        this.updateStatsDisplay();\n    }\n    \n    /**\n     * Bind event listeners\n     */\n    bindEventListeners() {\n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (this.currentSession && this.currentSession.active) {\n                this.handleKeyboardShortcuts(e);\n            }\n        });\n    }\n    \n    /**\n     * Handle keyboard shortcuts during SRS session\n     * @param {KeyboardEvent} e - Keyboard event\n     */\n    handleKeyboardShortcuts(e) {\n        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {\n            return; // Don't interfere with input\n        }\n        \n        switch (e.key) {\n            case ' ': // Spacebar - reveal verse\n                e.preventDefault();\n                this.revealVerse();\n                break;\n            case 'Enter': // Enter - check answer\n                if (e.ctrlKey) {\n                    e.preventDefault();\n                    this.checkAnswer();\n                }\n                break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n                if (this.isAnswerRevealed()) {\n                    e.preventDefault();\n                    this.submitRating(parseInt(e.key));\n                }\n                break;\n        }\n    }\n    \n    // ==========================================\n    // CARD MANAGEMENT\n    // ==========================================\n    \n    /**\n     * Add new card to SRS system\n     * @param {Object} cardData - Card data\n     * @returns {string} Card ID\n     */\n    addCard(cardData) {\n        const {\n            reference,\n            text,\n            version = 'rv1960',\n            category = 'general',\n            difficulty = 'medium',\n            tags = []\n        } = cardData;\n        \n        const cardId = this.generateCardId();\n        \n        const card = {\n            id: cardId,\n            reference,\n            text,\n            version,\n            category,\n            difficulty,\n            tags,\n            created: Date.now(),\n            lastReviewed: null,\n            nextReview: Date.now(), // Available immediately\n            interval: 1,\n            easeFactor: SRS_CONFIG.easeFactor.initial,\n            repetitions: 0,\n            lapses: 0,\n            reviews: [],\n            stats: {\n                totalTime: 0,\n                averageAccuracy: 0,\n                fastestTime: null,\n                slowestTime: null\n            }\n        };\n        \n        this.cards.push(card);\n        this.updateState();\n        \n        uiManager.showNotification(\n            `Vers칤culo a침adido: ${reference}`,\n            'success',\n            { duration: 3000 }\n        );\n        \n        return cardId;\n    }\n    \n    /**\n     * Remove card from SRS system\n     * @param {string} cardId - Card ID\n     * @returns {boolean}\n     */\n    removeCard(cardId) {\n        const cardIndex = this.cards.findIndex(card => card.id === cardId);\n        \n        if (cardIndex === -1) {\n            return false;\n        }\n        \n        const card = this.cards[cardIndex];\n        this.cards.splice(cardIndex, 1);\n        \n        // Remove from schedule\n        this.schedule = this.schedule.filter(item => item.cardId !== cardId);\n        \n        this.updateState();\n        \n        uiManager.showNotification(\n            `Vers칤culo eliminado: ${card.reference}`,\n            'info',\n            { duration: 3000 }\n        );\n        \n        return true;\n    }\n    \n    /**\n     * Get card by ID\n     * @param {string} cardId - Card ID\n     * @returns {Object|null}\n     */\n    getCard(cardId) {\n        return this.cards.find(card => card.id === cardId) || null;\n    }\n    \n    /**\n     * Update card data\n     * @param {string} cardId - Card ID\n     * @param {Object} updates - Updates to apply\n     * @returns {boolean}\n     */\n    updateCard(cardId, updates) {\n        const card = this.getCard(cardId);\n        if (!card) return false;\n        \n        Object.assign(card, updates);\n        this.updateState();\n        \n        return true;\n    }\n    \n    /**\n     * Generate unique card ID\n     * @returns {string}\n     */\n    generateCardId() {\n        return 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n    \n    // ==========================================\n    // SCHEDULING ALGORITHM (SM-2 BASED)\n    // ==========================================\n    \n    /**\n     * Calculate next review using SM-2 algorithm\n     * @param {Object} card - Card object\n     * @param {number} rating - Rating (1-4)\n     * @returns {Object} Updated scheduling data\n     */\n    calculateNextReview(card, rating) {\n        const { easeFactor, repetitions, interval } = card;\n        let newEaseFactor = easeFactor;\n        let newRepetitions = repetitions;\n        let newInterval = interval;\n        \n        if (rating < 3) {\n            // Incorrect response\n            newRepetitions = 0;\n            newInterval = 1;\n            card.lapses = (card.lapses || 0) + 1;\n        } else {\n            // Correct response\n            newRepetitions += 1;\n            \n            if (newRepetitions === 1) {\n                newInterval = 1;\n            } else if (newRepetitions === 2) {\n                newInterval = 6;\n            } else {\n                newInterval = Math.round(interval * newEaseFactor);\n            }\n            \n            // Update ease factor\n            newEaseFactor = newEaseFactor + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));\n            newEaseFactor = Math.max(SRS_CONFIG.easeFactor.minimum, newEaseFactor);\n            newEaseFactor = Math.min(SRS_CONFIG.easeFactor.maximum, newEaseFactor);\n        }\n        \n        const nextReviewTime = Date.now() + (newInterval * 24 * 60 * 60 * 1000);\n        \n        return {\n            easeFactor: newEaseFactor,\n            repetitions: newRepetitions,\n            interval: newInterval,\n            nextReview: nextReviewTime\n        };\n    }\n    \n    /**\n     * Update daily schedule\n     */\n    updateDailySchedule() {\n        const now = Date.now();\n        const startOfDay = new Date();\n        startOfDay.setHours(0, 0, 0, 0);\n        const endOfDay = new Date();\n        endOfDay.setHours(23, 59, 59, 999);\n        \n        // Get cards due for review\n        const dueCards = this.cards.filter(card => {\n            return card.nextReview <= now;\n        });\n        \n        // Get new cards (never reviewed)\n        const newCards = this.cards.filter(card => {\n            return card.repetitions === 0 && card.lastReviewed === null;\n        });\n        \n        // Limit new cards per day\n        const dailyNewLimit = getState('srs.settings.dailyNewLimit', SRS_CONFIG.limits.dailyNew);\n        const limitedNewCards = newCards.slice(0, dailyNewLimit);\n        \n        // Limit review cards per day\n        const dailyReviewLimit = getState('srs.settings.dailyReviewLimit', SRS_CONFIG.limits.dailyReview);\n        const limitedDueCards = dueCards.slice(0, dailyReviewLimit);\n        \n        // Update schedule state\n        setState('srs.stats.newToday', limitedNewCards.length);\n        setState('srs.stats.reviewToday', limitedDueCards.length);\n        setState('srs.stats.totalCards', this.cards.length);\n        \n        // Create today's schedule\n        this.schedule = [\n            ...limitedNewCards.map(card => ({ cardId: card.id, type: 'new' })),\n            ...limitedDueCards.map(card => ({ cardId: card.id, type: 'review' }))\n        ];\n        \n        // Shuffle schedule\n        this.schedule = this.shuffleArray(this.schedule);\n        \n        console.log(`Schedule updated: ${limitedNewCards.length} new, ${limitedDueCards.length} review`);\n    }\n    \n    /**\n     * Shuffle array using Fisher-Yates algorithm\n     * @param {Array} array - Array to shuffle\n     * @returns {Array}\n     */\n    shuffleArray(array) {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n    \n    // ==========================================\n    // SESSION MANAGEMENT\n    // ==========================================\n    \n    /**\n     * Start SRS session\n     * @param {Object} options - Session options\n     * @returns {boolean}\n     */\n    startSession(options = {}) {\n        const {\n            maxCards = SRS_CONFIG.limits.sessionMax,\n            timeLimit = null,\n            cardTypes = ['new', 'review']\n        } = options;\n        \n        if (this.currentSession && this.currentSession.active) {\n            return false; // Session already active\n        }\n        \n        // Filter schedule by card types\n        const sessionSchedule = this.schedule.filter(item => \n            cardTypes.includes(item.type)\n        ).slice(0, maxCards);\n        \n        if (sessionSchedule.length === 0) {\n            uiManager.showNotification(\n                'No hay cartas disponibles para revisar',\n                'info',\n                { duration: 3000 }\n            );\n            return false;\n        }\n        \n        this.currentSession = {\n            active: true,\n            startTime: Date.now(),\n            timeLimit,\n            schedule: sessionSchedule,\n            currentIndex: 0,\n            completed: [],\n            stats: {\n                totalTime: 0,\n                correctAnswers: 0,\n                totalAnswers: 0\n            }\n        };\n        \n        setState('srs.session', this.currentSession);\n        \n        this.loadNextCard();\n        \n        uiManager.showNotification(\n            `Sesi칩n iniciada: ${sessionSchedule.length} cartas`,\n            'success',\n            { duration: 2000 }\n        );\n        \n        return true;\n    }\n    \n    /**\n     * End current session\n     */\n    endSession() {\n        if (!this.currentSession || !this.currentSession.active) {\n            return;\n        }\n        \n        const session = this.currentSession;\n        const duration = Date.now() - session.startTime;\n        \n        // Calculate session stats\n        const accuracy = session.stats.totalAnswers > 0 \n            ? (session.stats.correctAnswers / session.stats.totalAnswers) * 100 \n            : 0;\n        \n        // Update user progress\n        this.updateUserProgress({\n            sessionTime: duration,\n            cardsCompleted: session.completed.length,\n            accuracy\n        });\n        \n        // End session\n        this.currentSession.active = false;\n        setState('srs.session.active', false);\n        \n        // Show completion notification\n        uiManager.showNotification(\n            `Sesi칩n completada: ${session.completed.length} cartas en ${this.formatDuration(duration)}`,\n            'success',\n            { duration: 5000 }\n        );\n        \n        // Update stats display\n        this.updateStatsDisplay();\n    }\n    \n    /**\n     * Load next card in session\n     */\n    loadNextCard() {\n        if (!this.currentSession || !this.currentSession.active) {\n            return;\n        }\n        \n        const session = this.currentSession;\n        \n        if (session.currentIndex >= session.schedule.length) {\n            this.endSession();\n            return;\n        }\n        \n        const scheduleItem = session.schedule[session.currentIndex];\n        const card = this.getCard(scheduleItem.cardId);\n        \n        if (!card) {\n            console.error('Card not found:', scheduleItem.cardId);\n            this.skipCurrentCard();\n            return;\n        }\n        \n        this.currentCard = card;\n        this.cardStartTime = Date.now();\n        \n        // Update UI\n        this.displayCard(card);\n        \n        // Reset input\n        if (this.verseInput) {\n            this.verseInput.value = '';\n            this.verseInput.focus();\n        }\n        \n        // Hide result area\n        this.hideResultArea();\n    }\n    \n    /**\n     * Skip current card\n     */\n    skipCurrentCard() {\n        if (this.currentSession) {\n            this.currentSession.currentIndex++;\n            this.loadNextCard();\n        }\n    }\n    \n    // ==========================================\n    // UI INTERACTION METHODS\n    // ==========================================\n    \n    /**\n     * Display card in UI\n     * @param {Object} card - Card to display\n     */\n    displayCard(card) {\n        const citationElement = $('#citation');\n        if (citationElement) {\n            citationElement.textContent = card.reference;\n            citationElement.classList.remove('revealed');\n        }\n        \n        // Update progress indicator\n        this.updateProgressIndicator();\n    }\n    \n    /**\n     * Update progress indicator\n     */\n    updateProgressIndicator() {\n        if (!this.currentSession) return;\n        \n        const current = this.currentSession.currentIndex + 1;\n        const total = this.currentSession.schedule.length;\n        \n        // Could add a progress bar here\n        console.log(`Progress: ${current}/${total}`);\n    }\n    \n    /**\n     * Reveal verse text\n     */\n    revealVerse() {\n        if (!this.currentCard) return;\n        \n        const citationElement = $('#citation');\n        if (citationElement) {\n            citationElement.textContent = this.currentCard.text;\n            citationElement.classList.add('revealed');\n        }\n        \n        // Enable rating buttons\n        this.enableRatingButtons();\n    }\n    \n    /**\n     * Check if answer is revealed\n     * @returns {boolean}\n     */\n    isAnswerRevealed() {\n        const citationElement = $('#citation');\n        return citationElement && citationElement.classList.contains('revealed');\n    }\n    \n    /**\n     * Handle input change\n     */\n    handleInputChange() {\n        if (!this.currentCard || !this.verseInput) return;\n        \n        const userInput = this.verseInput.value.trim();\n        const correctText = this.currentCard.text;\n        \n        // Calculate similarity\n        const similarity = stringSimilarity(userInput.toLowerCase(), correctText.toLowerCase());\n        \n        // Update input styling based on similarity\n        this.updateInputStyling(similarity);\n    }\n    \n    /**\n     * Update input styling based on similarity\n     * @param {number} similarity - Similarity score (0-1)\n     */\n    updateInputStyling(similarity) {\n        if (!this.verseInput) return;\n        \n        this.verseInput.classList.remove('error', 'warning', 'success');\n        \n        if (similarity >= 0.9) {\n            this.verseInput.classList.add('success');\n        } else if (similarity >= 0.7) {\n            this.verseInput.classList.add('warning');\n        } else if (similarity < 0.5 && this.verseInput.value.length > 10) {\n            this.verseInput.classList.add('error');\n        }\n    }\n    \n    /**\n     * Check answer\n     */\n    checkAnswer() {\n        if (!this.currentCard || !this.verseInput) return;\n        \n        const userAnswer = this.verseInput.value.trim();\n        const correctAnswer = this.currentCard.text;\n        \n        if (userAnswer.length === 0) {\n            uiManager.showNotification('Por favor, escribe tu respuesta', 'warning');\n            return;\n        }\n        \n        // Calculate accuracy\n        const similarity = stringSimilarity(userAnswer.toLowerCase(), correctAnswer.toLowerCase());\n        const accuracy = Math.round(similarity * 100);\n        \n        // Show comparison\n        this.showComparison(userAnswer, correctAnswer, accuracy);\n        \n        // Reveal verse if not already revealed\n        if (!this.isAnswerRevealed()) {\n            this.revealVerse();\n        }\n        \n        // Store check data for rating\n        this.lastCheckData = {\n            userAnswer,\n            correctAnswer,\n            accuracy,\n            timeSpent: Date.now() - this.cardStartTime\n        };\n    }\n    \n    /**\n     * Show answer comparison\n     * @param {string} userAnswer - User's answer\n     * @param {string} correctAnswer - Correct answer\n     * @param {number} accuracy - Accuracy percentage\n     */\n    showComparison(userAnswer, correctAnswer, accuracy) {\n        const resultArea = $('#resultArea');\n        if (!resultArea) return;\n        \n        const userAnswerElement = $('#userAnswer');\n        const correctAnswerElement = $('#correctAnswer');\n        const diffOutputElement = $('#diffOutput');\n        \n        if (userAnswerElement) {\n            userAnswerElement.textContent = userAnswer;\n        }\n        \n        if (correctAnswerElement) {\n            correctAnswerElement.textContent = correctAnswer;\n        }\n        \n        if (diffOutputElement) {\n            const diff = this.generateDiffAnalysis(userAnswer, correctAnswer, accuracy);\n            diffOutputElement.innerHTML = diff;\n        }\n        \n        resultArea.classList.remove('hidden');\n        this.enableRatingButtons();\n    }\n    \n    /**\n     * Generate diff analysis\n     * @param {string} userAnswer - User's answer\n     * @param {string} correctAnswer - Correct answer\n     * @param {number} accuracy - Accuracy percentage\n     * @returns {string}\n     */\n    generateDiffAnalysis(userAnswer, correctAnswer, accuracy) {\n        let analysis = `<strong>Precisi칩n: ${accuracy}%</strong><br>`;\n        \n        if (accuracy >= 95) {\n            analysis += '<span class=\"text-green-400\">춰Excelente! Casi perfecto.</span>';\n        } else if (accuracy >= 80) {\n            analysis += '<span class=\"text-blue-400\">Muy bien. Peque침os detalles por mejorar.</span>';\n        } else if (accuracy >= 60) {\n            analysis += '<span class=\"text-yellow-400\">Bien. Revisa algunas palabras.</span>';\n        } else {\n            analysis += '<span class=\"text-red-400\">Necesita m치s pr치ctica. 춰Sigue intentando!</span>';\n        }\n        \n        return analysis;\n    }\n    \n    /**\n     * Hide result area\n     */\n    hideResultArea() {\n        const resultArea = $('#resultArea');\n        if (resultArea) {\n            resultArea.classList.add('hidden');\n        }\n        \n        this.disableRatingButtons();\n    }\n    \n    /**\n     * Enable rating buttons\n     */\n    enableRatingButtons() {\n        const ratingButtons = $$('.srs-rating-btn');\n        ratingButtons.forEach(button => {\n            button.disabled = false;\n            button.classList.remove('disabled');\n        });\n    }\n    \n    /**\n     * Disable rating buttons\n     */\n    disableRatingButtons() {\n        const ratingButtons = $$('.srs-rating-btn');\n        ratingButtons.forEach(button => {\n            button.disabled = true;\n            button.classList.add('disabled');\n        });\n    }\n    \n    /**\n     * Submit rating\n     * @param {number} rating - Rating (1-4)\n     */\n    submitRating(rating) {\n        if (!this.currentCard || !this.currentSession) return;\n        \n        const timeSpent = Date.now() - this.cardStartTime;\n        const accuracy = this.lastCheckData ? this.lastCheckData.accuracy : 0;\n        \n        // Update card with new scheduling\n        const schedulingData = this.calculateNextReview(this.currentCard, rating);\n        Object.assign(this.currentCard, schedulingData);\n        \n        // Record review\n        const review = {\n            timestamp: Date.now(),\n            rating,\n            timeSpent,\n            accuracy,\n            userAnswer: this.lastCheckData ? this.lastCheckData.userAnswer : ''\n        };\n        \n        this.currentCard.reviews.push(review);\n        this.currentCard.lastReviewed = Date.now();\n        \n        // Update card stats\n        this.updateCardStats(this.currentCard, review);\n        \n        // Update session stats\n        this.currentSession.stats.totalAnswers++;\n        if (rating >= 3) {\n            this.currentSession.stats.correctAnswers++;\n        }\n        this.currentSession.stats.totalTime += timeSpent;\n        \n        // Add to completed\n        this.currentSession.completed.push({\n            cardId: this.currentCard.id,\n            rating,\n            timeSpent,\n            accuracy\n        });\n        \n        // Show rating feedback\n        this.showRatingFeedback(rating);\n        \n        // Move to next card\n        setTimeout(() => {\n            this.currentSession.currentIndex++;\n            this.loadNextCard();\n        }, 1500);\n        \n        // Update state\n        this.updateState();\n    }\n    \n    /**\n     * Update card statistics\n     * @param {Object} card - Card object\n     * @param {Object} review - Review data\n     */\n    updateCardStats(card, review) {\n        const stats = card.stats;\n        \n        // Update total time\n        stats.totalTime += review.timeSpent;\n        \n        // Update accuracy\n        const totalReviews = card.reviews.length;\n        const totalAccuracy = card.reviews.reduce((sum, r) => sum + (r.accuracy || 0), 0);\n        stats.averageAccuracy = totalAccuracy / totalReviews;\n        \n        // Update fastest/slowest times\n        if (!stats.fastestTime || review.timeSpent < stats.fastestTime) {\n            stats.fastestTime = review.timeSpent;\n        }\n        if (!stats.slowestTime || review.timeSpent > stats.slowestTime) {\n            stats.slowestTime = review.timeSpent;\n        }\n    }\n    \n    /**\n     * Show rating feedback\n     * @param {number} rating - Rating given\n     */\n    showRatingFeedback(rating) {\n        const feedbackElement = $('#srsFeedback');\n        if (!feedbackElement) return;\n        \n        const config = SRS_CONFIG.ratings[rating];\n        const nextInterval = this.currentCard.interval;\n        \n        let message = `${config.emoji} ${config.label}: ${config.description}`;\n        \n        if (rating >= 3) {\n            message += `<br>Pr칩xima revisi칩n en ${nextInterval} d칤a${nextInterval > 1 ? 's' : ''}.`;\n        } else {\n            message += `<br>Volver치s a verla pronto para reforzarla.`;\n        }\n        \n        feedbackElement.innerHTML = message;\n        feedbackElement.className = `text-sm text-[var(--text-muted)] mt-3 text-center rating-${rating}`;\n    }\n    \n    // ==========================================\n    // STATISTICS AND PROGRESS\n    // ==========================================\n    \n    /**\n     * Update statistics display\n     */\n    updateStatsDisplay() {\n        this.updateGlobalStats();\n        this.updateCardsDisplay();\n    }\n    \n    /**\n     * Update global SRS statistics\n     */\n    updateGlobalStats() {\n        const totalCards = this.cards.length;\n        const memorizedCards = this.cards.filter(card => \n            card.repetitions >= 3 && card.easeFactor >= 2.5\n        ).length;\n        \n        // Calculate streak\n        const streak = this.calculateCurrentStreak();\n        \n        // Calculate next reviews\n        const now = Date.now();\n        const nextReviews = this.cards.filter(card => \n            card.nextReview > now && card.nextReview <= now + (24 * 60 * 60 * 1000)\n        ).length;\n        \n        // Update UI elements\n        const statElements = {\n            totalCards: $$('[data-stat=\"totalCards\"]'),\n            memorizedCards: $$('[data-stat=\"memorizedCards\"]'),\n            streak: $$('[data-stat=\"streak\"]'),\n            nextReviews: $$('[data-stat=\"nextReviews\"]')\n        };\n        \n        Object.entries(statElements).forEach(([stat, elements]) => {\n            const value = eval(stat); // Gets the variable value\n            elements.forEach(element => {\n                if (element) {\n                    element.textContent = value;\n                }\n            });\n        });\n        \n        // Update state\n        setState('srs.stats.totalCards', totalCards);\n        setState('srs.stats.completed', memorizedCards);\n    }\n    \n    /**\n     * Calculate current memorization streak\n     * @returns {number}\n     */\n    calculateCurrentStreak() {\n        // This would calculate consecutive days with SRS activity\n        // For now, return a simple calculation\n        const userProgress = getState('user.progress', {});\n        return userProgress.streak || 0;\n    }\n    \n    /**\n     * Update cards display in stats\n     */\n    updateCardsDisplay() {\n        // Update the stat cards in the UI\n        const statCards = $$('.srs-stat-card');\n        \n        if (statCards.length >= 3) {\n            const totalCards = this.cards.length;\n            const streak = this.calculateCurrentStreak();\n            const nextReviews = this.getNextReviewsCount();\n            \n            // Update the numbers in the stat cards\n            const statNumbers = $$('.srs-stat-card .text-3xl');\n            if (statNumbers[0]) statNumbers[0].textContent = totalCards;\n            if (statNumbers[1]) statNumbers[1].textContent = streak;\n            if (statNumbers[2]) statNumbers[2].textContent = nextReviews;\n        }\n    }\n    \n    /**\n     * Get count of cards due for review in next 24 hours\n     * @returns {number}\n     */\n    getNextReviewsCount() {\n        const now = Date.now();\n        const tomorrow = now + (24 * 60 * 60 * 1000);\n        \n        return this.cards.filter(card => \n            card.nextReview > now && card.nextReview <= tomorrow\n        ).length;\n    }\n    \n    /**\n     * Update user progress based on session\n     * @param {Object} sessionData - Session data\n     */\n    updateUserProgress(sessionData) {\n        const currentProgress = getState('user.progress', {});\n        const stats = currentProgress.stats || {};\n        \n        // Update stats\n        stats.totalStudyTime = (stats.totalStudyTime || 0) + sessionData.sessionTime;\n        stats.totalVersesMemorized = (stats.totalVersesMemorized || 0) + sessionData.cardsCompleted;\n        \n        // Calculate XP gain\n        const xpGain = sessionData.cardsCompleted * GAMIFICATION_CONFIG.xp.verseMemorized;\n        const currentXP = currentProgress.xp || 0;\n        const newXP = currentXP + xpGain;\n        \n        // Update progress\n        updateState('user.progress', {\n            xp: newXP,\n            stats\n        });\n        \n        if (xpGain > 0) {\n            uiManager.showNotification(\n                `+${xpGain} XP por memorizaci칩n`,\n                'success',\n                { duration: 3000 }\n            );\n        }\n    }\n    \n    // ==========================================\n    // UTILITY METHODS\n    // ==========================================\n    \n    /**\n     * Format duration in milliseconds\n     * @param {number} ms - Duration in milliseconds\n     * @returns {string}\n     */\n    formatDuration(ms) {\n        const seconds = Math.floor(ms / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const hours = Math.floor(minutes / 60);\n        \n        if (hours > 0) {\n            return `${hours}h ${minutes % 60}m`;\n        } else if (minutes > 0) {\n            return `${minutes}m ${seconds % 60}s`;\n        } else {\n            return `${seconds}s`;\n        }\n    }\n    \n    /**\n     * Update state in state manager\n     */\n    updateState() {\n        setState('srs.cards', this.cards);\n        setState('srs.schedule', this.schedule);\n    }\n    \n    /**\n     * Setup state subscriptions\n     */\n    setupStateSubscriptions() {\n        // Subscribe to settings changes\n        subscribe('srs.settings', () => {\n            this.updateDailySchedule();\n        });\n        \n        // Subscribe to app state changes\n        subscribe('app.currentSubSection', (subSection) => {\n            if (subSection === 'memorizacion') {\n                this.updateStatsDisplay();\n            }\n        });\n    }\n    \n    /**\n     * Schedule daily maintenance\n     */\n    scheduleDailyMaintenance() {\n        // Check if we need to update schedule (new day)\n        const now = new Date();\n        const tomorrow = new Date(now);\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        tomorrow.setHours(0, 0, 0, 0);\n        \n        const msUntilMidnight = tomorrow.getTime() - now.getTime();\n        \n        setTimeout(() => {\n            this.updateDailySchedule();\n            this.updateStatsDisplay();\n            \n            // Schedule next day\n            setInterval(() => {\n                this.updateDailySchedule();\n                this.updateStatsDisplay();\n            }, 24 * 60 * 60 * 1000);\n        }, msUntilMidnight);\n    }\n    \n    /**\n     * Get SRS system statistics\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            totalCards: this.cards.length,\n            totalReviews: this.cards.reduce((sum, card) => sum + card.reviews.length, 0),\n            averageEaseFactor: this.cards.reduce((sum, card) => sum + card.easeFactor, 0) / this.cards.length,\n            scheduledToday: this.schedule.length,\n            isSessionActive: this.currentSession && this.currentSession.active,\n            isInitialized: this.isInitialized\n        };\n    }\n    \n    /**\n     * Debug method\n     */\n    debug() {\n        console.group('游 SRS System Debug');\n        console.log('Statistics:', this.getStats());\n        console.log('Cards:', this.cards);\n        console.log('Schedule:', this.schedule);\n        console.log('Current session:', this.currentSession);\n        console.groupEnd();\n    }\n}\n\n// ==========================================\n// CREATE AND EXPORT SRS SYSTEM INSTANCE\n// ==========================================\n\nconst srsSystem = new SRSSystem();\n\nexport default srsSystem;\nexport { SRSSystem };"